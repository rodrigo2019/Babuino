CCS PCM C Compiler, Version 5.058, 5967               13-set-16 18:22

               Filename:   C:\Users\rodri\Dropbox\Rodrigo\Projetos PIC\BABUINO v1\Firmware\1455\1455 - USB-Serial v3\USBSerialV3.lst

               ROM used:   4519 words (55%)
                           Largest free fragment is 1919
               RAM used:   316 (31%) at main() level
                           416 (41%) worst case
               Stack used: 12 locations (6 in main + 6 for interrupts)
               Stack size: 16

*
0000:  MOVLP  00
0001:  GOTO   6E0
0002:  NOP
*
0004:  CLRF   03
0005:  MOVLP  00
0006:  MOVLB  00
0007:  MOVF   77,W
0008:  MOVLB  02
0009:  MOVWF  33
000A:  MOVF   78,W
000B:  MOVWF  34
000C:  MOVF   79,W
000D:  MOVWF  35
000E:  MOVF   7A,W
000F:  MOVWF  36
0010:  MOVLB  03
0011:  MOVF   11,W
0012:  MOVLB  02
0013:  MOVWF  37
0014:  MOVLB  03
0015:  MOVF   12,W
0016:  MOVLB  02
0017:  MOVWF  38
0018:  MOVLB  03
0019:  MOVF   13,W
001A:  MOVLB  02
001B:  MOVWF  39
001C:  MOVLB  03
001D:  MOVF   14,W
001E:  MOVLB  02
001F:  MOVWF  3A
0020:  CLRF   05
0021:  MOVLW  91
0022:  MOVWF  04
0023:  BTFSS  00.0
0024:  GOTO   029
0025:  MOVLB  00
0026:  BTFSC  11.0
0027:  GOTO   04B
0028:  MOVLB  02
0029:  CLRF   05
002A:  MOVLW  92
002B:  MOVWF  04
002C:  BTFSS  00.2
002D:  GOTO   032
002E:  MOVLB  00
002F:  BTFSC  12.2
0030:  GOTO   04D
0031:  MOVLB  02
0032:  MOVF   33,W
0033:  MOVWF  77
0034:  MOVF   34,W
0035:  MOVWF  78
0036:  MOVF   35,W
0037:  MOVWF  79
0038:  MOVF   36,W
0039:  MOVWF  7A
003A:  MOVF   37,W
003B:  MOVLB  03
003C:  MOVWF  11
003D:  MOVLB  02
003E:  MOVF   38,W
003F:  MOVLB  03
0040:  MOVWF  12
0041:  MOVLB  02
0042:  MOVF   39,W
0043:  MOVLB  03
0044:  MOVWF  13
0045:  MOVLB  02
0046:  MOVF   3A,W
0047:  MOVLB  03
0048:  MOVWF  14
0049:  RETFIE
004A:  MOVLB  00
004B:  MOVLP  00
004C:  GOTO   502
004D:  MOVLP  08
004E:  GOTO   000
.................... #include <USBSerialV3.h> 
.................... #include <16F1455.h> 
.................... //////////// Standard Header file for the PIC16F1455 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F1455 
004F:  BRW
0050:  RETLW  04
0051:  RETLW  03
0052:  RETLW  09
0053:  RETLW  04
0054:  RETLW  10
0055:  RETLW  03
0056:  RETLW  42
0057:  RETLW  00
0058:  RETLW  61
0059:  RETLW  00
005A:  RETLW  62
005B:  RETLW  00
005C:  RETLW  75
005D:  RETLW  00
005E:  RETLW  49
005F:  RETLW  00
0060:  RETLW  4E
0061:  RETLW  00
0062:  RETLW  4F
0063:  RETLW  00
0064:  RETLW  18
0065:  RETLW  03
0066:  RETLW  42
0067:  RETLW  00
0068:  RETLW  61
0069:  RETLW  00
006A:  RETLW  62
006B:  RETLW  00
006C:  RETLW  75
006D:  RETLW  00
006E:  RETLW  49
006F:  RETLW  00
0070:  RETLW  4E
0071:  RETLW  00
0072:  RETLW  4F
0073:  RETLW  00
0074:  RETLW  20
0075:  RETLW  00
0076:  RETLW  55
0077:  RETLW  00
0078:  RETLW  4E
0079:  RETLW  00
007A:  RETLW  4F
007B:  RETLW  00
007C:  BRW
007D:  RETLW  00
007E:  RETLW  03
007F:  RETLW  02
0080:  RETLW  FF
0081:  RETLW  FF
0082:  RETLW  FF
0083:  RETLW  FF
0084:  RETLW  FF
0085:  RETLW  FF
0086:  RETLW  FF
0087:  RETLW  FF
0088:  RETLW  FF
0089:  RETLW  FF
008A:  RETLW  FF
008B:  RETLW  FF
008C:  RETLW  FF
008D:  BRW
008E:  RETLW  00
008F:  RETLW  FF
0090:  RETLW  02
0091:  RETLW  FF
0092:  RETLW  FF
0093:  RETLW  FF
0094:  RETLW  FF
0095:  RETLW  FF
0096:  RETLW  FF
0097:  RETLW  FF
0098:  RETLW  FF
0099:  RETLW  FF
009A:  RETLW  FF
009B:  RETLW  FF
009C:  RETLW  FF
009D:  RETLW  FF
009E:  BRW
009F:  RETLW  08
00A0:  RETLW  00
00A1:  RETLW  0B
00A2:  RETLW  00
00A3:  RETLW  40
00A4:  RETLW  00
00A5:  RETLW  00
00A6:  RETLW  00
00A7:  RETLW  00
00A8:  RETLW  00
00A9:  RETLW  00
00AA:  RETLW  00
00AB:  RETLW  00
00AC:  RETLW  00
00AD:  RETLW  00
00AE:  RETLW  00
00AF:  RETLW  00
00B0:  RETLW  00
00B1:  RETLW  00
00B2:  RETLW  00
00B3:  RETLW  00
00B4:  RETLW  00
00B5:  RETLW  00
00B6:  RETLW  00
00B7:  RETLW  00
00B8:  RETLW  00
00B9:  RETLW  00
00BA:  RETLW  00
00BB:  RETLW  00
00BC:  RETLW  00
00BD:  RETLW  00
00BE:  RETLW  00
00BF:  BRW
00C0:  RETLW  08
00C1:  RETLW  00
00C2:  RETLW  00
00C3:  RETLW  00
00C4:  RETLW  40
00C5:  RETLW  00
00C6:  RETLW  00
00C7:  RETLW  00
00C8:  RETLW  00
00C9:  RETLW  00
00CA:  RETLW  00
00CB:  RETLW  00
00CC:  RETLW  00
00CD:  RETLW  00
00CE:  RETLW  00
00CF:  RETLW  00
00D0:  RETLW  00
00D1:  RETLW  00
00D2:  RETLW  00
00D3:  RETLW  00
00D4:  RETLW  00
00D5:  RETLW  00
00D6:  RETLW  00
00D7:  RETLW  00
00D8:  RETLW  00
00D9:  RETLW  00
00DA:  RETLW  00
00DB:  RETLW  00
00DC:  RETLW  00
00DD:  RETLW  00
00DE:  RETLW  00
00DF:  RETLW  00
00E0:  BRW
00E1:  RETLW  09
00E2:  RETLW  02
00E3:  RETLW  43
00E4:  RETLW  00
00E5:  RETLW  02
00E6:  RETLW  01
00E7:  RETLW  00
00E8:  RETLW  80
00E9:  RETLW  FA
00EA:  RETLW  09
00EB:  RETLW  04
00EC:  RETLW  00
00ED:  RETLW  00
00EE:  RETLW  01
00EF:  RETLW  02
00F0:  RETLW  02
00F1:  RETLW  01
00F2:  RETLW  00
00F3:  RETLW  05
00F4:  RETLW  24
00F5:  RETLW  00
00F6:  RETLW  10
00F7:  RETLW  01
00F8:  RETLW  04
00F9:  RETLW  24
00FA:  RETLW  02
00FB:  RETLW  02
00FC:  RETLW  05
00FD:  RETLW  24
00FE:  RETLW  06
00FF:  RETLW  00
0100:  RETLW  01
0101:  RETLW  05
0102:  RETLW  24
0103:  RETLW  01
0104:  RETLW  00
0105:  RETLW  01
0106:  RETLW  07
0107:  RETLW  05
0108:  RETLW  81
0109:  RETLW  03
010A:  RETLW  0B
010B:  RETLW  00
010C:  RETLW  FA
010D:  RETLW  09
010E:  RETLW  04
010F:  RETLW  01
0110:  RETLW  00
0111:  RETLW  02
0112:  RETLW  0A
0113:  RETLW  00
0114:  RETLW  00
0115:  RETLW  00
0116:  RETLW  07
0117:  RETLW  05
0118:  RETLW  02
0119:  RETLW  02
011A:  RETLW  40
011B:  RETLW  00
011C:  RETLW  01
011D:  RETLW  07
011E:  RETLW  05
011F:  RETLW  82
0120:  RETLW  02
0121:  RETLW  40
0122:  RETLW  00
0123:  RETLW  01
0124:  BRW
0125:  RETLW  02
0126:  BRW
0127:  RETLW  12
0128:  RETLW  17
0129:  RETLW  1B
012A:  RETLW  20
012B:  RETLW  FF
012C:  RETLW  FF
012D:  RETLW  FF
012E:  RETLW  FF
012F:  BRW
0130:  RETLW  12
0131:  RETLW  01
0132:  RETLW  10
0133:  RETLW  01
0134:  RETLW  02
0135:  RETLW  00
0136:  RETLW  00
0137:  RETLW  08
0138:  RETLW  61
0139:  RETLW  04
013A:  RETLW  03
013B:  RETLW  00
013C:  RETLW  00
013D:  RETLW  01
013E:  RETLW  01
013F:  RETLW  02
0140:  RETLW  00
0141:  RETLW  01
0142:  BRW
0143:  RETLW  41
0144:  RETLW  54
0145:  RETLW  2B
0146:  RETLW  42
0147:  RETLW  4F
0148:  RETLW  4F
0149:  RETLW  54
014A:  RETLW  0D
014B:  RETLW  00
014C:  BRW
014D:  RETLW  41
014E:  RETLW  54
014F:  RETLW  2B
0150:  RETLW  52
0151:  RETLW  53
0152:  RETLW  54
0153:  RETLW  0D
0154:  RETLW  00
0155:  BRW
0156:  RETLW  41
0157:  RETLW  54
0158:  RETLW  2B
0159:  RETLW  49
015A:  RETLW  4E
015B:  RETLW  46
015C:  RETLW  4F
015D:  RETLW  0D
015E:  RETLW  00
015F:  BRW
0160:  RETLW  41
0161:  RETLW  54
0162:  RETLW  2B
0163:  RETLW  49
0164:  RETLW  44
0165:  RETLW  4E
0166:  RETLW  3F
0167:  RETLW  0D
0168:  RETLW  00
0169:  BRW
016A:  RETLW  41
016B:  RETLW  54
016C:  RETLW  2B
016D:  RETLW  42
016E:  RETLW  41
016F:  RETLW  55
0170:  RETLW  44
0171:  RETLW  00
0172:  BRW
0173:  RETLW  20
0174:  RETLW  20
0175:  RETLW  20
0176:  RETLW  20
0177:  RETLW  20
0178:  RETLW  20
0179:  RETLW  20
017A:  RETLW  20
017B:  RETLW  20
017C:  RETLW  20
017D:  RETLW  20
017E:  RETLW  20
017F:  RETLW  20
0180:  RETLW  20
0181:  RETLW  20
0182:  RETLW  00
*
047C:  DATA C1,21
047D:  DATA CB,06
047E:  DATA 0A,00
047F:  DATA C1,21
0480:  DATA CB,06
0481:  DATA 0A,00
0482:  DATA 0D,05
0483:  DATA AD,16
0484:  DATA AD,16
0485:  DATA AD,16
0486:  DATA AD,16
0487:  DATA AD,16
0488:  DATA AD,16
0489:  DATA AD,16
048A:  DATA AD,16
048B:  DATA AD,16
048C:  DATA AD,16
048D:  DATA AD,16
048E:  DATA AD,06
048F:  DATA 0A,00
0490:  DATA C2,27
0491:  DATA 41,29
0492:  DATA 44,10
0493:  DATA 49,27
0494:  DATA C6,27
0495:  DATA D2,26
0496:  DATA 41,2A
0497:  DATA C9,27
0498:  DATA CE,06
0499:  DATA 0A,00
049A:  DATA C2,27
049B:  DATA 41,29
049C:  DATA 44,1D
049D:  DATA A0,2A
049E:  DATA CE,27
049F:  DATA 20,39
04A0:  DATA B2,06
04A1:  DATA 0A,00
04A2:  DATA D2,22
04A3:  DATA D6,24
04A4:  DATA D3,24
04A5:  DATA 4F,27
04A6:  DATA 3A,10
04A7:  DATA 31,17
04A8:  DATA 30,18
04A9:  DATA 0D,05
04AA:  DATA 00,01
04AB:  DATA 50,29
04AC:  DATA CF,21
04AD:  DATA C5,29
04AE:  DATA D3,27
04AF:  DATA 52,1D
04B0:  DATA 20,28
04B1:  DATA C9,21
04B2:  DATA A0,18
04B3:  DATA 38,23
04B4:  DATA 32,1B
04B5:  DATA 6B,19
04B6:  DATA B2,06
04B7:  DATA 0A,00
04B8:  DATA 43,29
04B9:  DATA D9,29
04BA:  DATA D4,20
04BB:  DATA 4C,1D
04BC:  DATA A0,18
04BD:  DATA B6,26
04BE:  DATA 68,3D
04BF:  DATA 0D,05
04C0:  DATA 00,01
04C1:  DATA 43,26
04C2:  DATA CF,21
04C3:  DATA 4B,1D
04C4:  DATA 20,1B
04C5:  DATA B4,26
04C6:  DATA 68,3D
04C7:  DATA 0D,05
04C8:  DATA 00,01
04C9:  DATA CD,24
04CA:  DATA D0,29
04CB:  DATA 3A,10
04CC:  DATA 31,1B
04CD:  DATA 0D,05
04CE:  DATA 00,01
04CF:  DATA 41,22
04D0:  DATA A0,21
04D1:  DATA C8,20
04D2:  DATA 4E,27
04D3:  DATA 45,26
04D4:  DATA 53,1D
04D5:  DATA A0,18
04D6:  DATA B3,06
04D7:  DATA 0A,00
04D8:  DATA D0,2B
04D9:  DATA 4D,1D
04DA:  DATA A0,1A
04DB:  DATA 0D,05
04DC:  DATA 00,01
04DD:  DATA C4,20
04DE:  DATA 43,1D
04DF:  DATA A0,18
04E0:  DATA A8,1A
04E1:  DATA 20,31
04E2:  DATA 69,3A
04E3:  DATA F3,14
04E4:  DATA 0D,05
04E5:  DATA 00,01
04E6:  DATA AD,16
04E7:  DATA AD,16
04E8:  DATA AD,16
04E9:  DATA AD,16
04EA:  DATA AD,16
04EB:  DATA AD,16
04EC:  DATA AD,16
04ED:  DATA AD,16
04EE:  DATA AD,16
04EF:  DATA AD,16
04F0:  DATA AD,16
04F1:  DATA AD,06
04F2:  DATA 0A,00
04F3:  DATA C2,30
04F4:  DATA E2,3A
04F5:  DATA 49,27
04F6:  DATA 4F,10
04F7:  DATA 55,27
04F8:  DATA 4F,00
04F9:  DATA C6,3A
04FA:  DATA F4,3A
04FB:  DATA F2,32
04FC:  DATA 20,33
04FD:  DATA E5,30
04FE:  DATA F4,3A
04FF:  DATA F2,32
0500:  DATA 0D,05
0501:  DATA 00,01
*
054B:  MOVLW  20
054C:  MOVLB  04
054D:  MOVWF  5B
054E:  CLRF   57
054F:  CLRF   58
0550:  CLRF   59
0551:  CLRF   5A
0552:  MOVF   51,W
0553:  MOVWF  7A
0554:  MOVF   50,W
0555:  MOVWF  79
0556:  MOVF   4F,W
0557:  MOVWF  78
0558:  MOVF   4E,W
0559:  MOVWF  77
055A:  BCF    03.0
055B:  BTFSS  77.0
055C:  GOTO   56B
055D:  MOVF   52,W
055E:  ADDWF  57,F
055F:  MOVF   53,W
0560:  BTFSC  03.0
0561:  INCFSZ 53,W
0562:  ADDWF  58,F
0563:  MOVF   54,W
0564:  BTFSC  03.0
0565:  INCFSZ 54,W
0566:  ADDWF  59,F
0567:  MOVF   55,W
0568:  BTFSC  03.0
0569:  INCFSZ 55,W
056A:  ADDWF  5A,F
056B:  RRF    5A,F
056C:  RRF    59,F
056D:  RRF    58,F
056E:  RRF    57,F
056F:  RRF    7A,F
0570:  RRF    79,F
0571:  RRF    78,F
0572:  RRF    77,F
0573:  DECFSZ 5B,F
0574:  GOTO   55A
0575:  MOVLB  00
0576:  RETURN
0577:  BTFSC  03.1
0578:  GOTO   57D
0579:  MOVLW  21
057A:  MOVWF  05
057B:  MOVLW  77
057C:  MOVWF  04
057D:  CLRF   77
057E:  CLRF   78
057F:  CLRF   79
0580:  CLRF   7A
0581:  MOVLB  04
0582:  CLRF   57
0583:  CLRF   58
0584:  CLRF   59
0585:  CLRF   5A
0586:  MOVF   55,W
0587:  IORWF  54,W
0588:  IORWF  53,W
0589:  IORWF  52,W
058A:  BTFSC  03.2
058B:  GOTO   5BC
058C:  MOVLW  20
058D:  MOVWF  5B
058E:  BCF    03.0
058F:  RLF    4E,F
0590:  RLF    4F,F
0591:  RLF    50,F
0592:  RLF    51,F
0593:  RLF    57,F
0594:  RLF    58,F
0595:  RLF    59,F
0596:  RLF    5A,F
0597:  MOVF   55,W
0598:  SUBWF  5A,W
0599:  BTFSS  03.2
059A:  GOTO   5A5
059B:  MOVF   54,W
059C:  SUBWF  59,W
059D:  BTFSS  03.2
059E:  GOTO   5A5
059F:  MOVF   53,W
05A0:  SUBWF  58,W
05A1:  BTFSS  03.2
05A2:  GOTO   5A5
05A3:  MOVF   52,W
05A4:  SUBWF  57,W
05A5:  BTFSS  03.0
05A6:  GOTO   5B6
05A7:  MOVF   52,W
05A8:  SUBWF  57,F
05A9:  MOVF   53,W
05AA:  BTFSS  03.0
05AB:  INCFSZ 53,W
05AC:  SUBWF  58,F
05AD:  MOVF   54,W
05AE:  BTFSS  03.0
05AF:  INCFSZ 54,W
05B0:  SUBWF  59,F
05B1:  MOVF   55,W
05B2:  BTFSS  03.0
05B3:  INCFSZ 55,W
05B4:  SUBWF  5A,F
05B5:  BSF    03.0
05B6:  RLF    77,F
05B7:  RLF    78,F
05B8:  RLF    79,F
05B9:  RLF    7A,F
05BA:  DECFSZ 5B,F
05BB:  GOTO   58E
05BC:  MOVF   57,W
05BD:  MOVWF  00
05BE:  MOVF   58,W
05BF:  MOVWI  W,[FSR0+01]
05C0:  MOVF   59,W
05C1:  MOVWI  W,[FSR0+02]
05C2:  MOVF   5A,W
05C3:  MOVWI  W,[FSR0+03]
05C4:  MOVLB  00
05C5:  RETURN
*
0694:  MOVF   0B,W
0695:  BCF    0B.7
0696:  MOVLB  03
0697:  BSF    15.7
0698:  BSF    15.0
0699:  NOP
069A:  NOP
069B:  BTFSC  09.7
069C:  BSF    0B.7
069D:  MOVF   13,W
069E:  ANDLW  7F
069F:  BTFSC  03.2
06A0:  GOTO   6D0
06A1:  MOVWF  6A
06A2:  MOVF   11,W
06A3:  MOVWF  6B
06A4:  MOVF   12,W
06A5:  MOVWF  6C
06A6:  MOVF   6A,W
06A7:  MOVWF  6D
06A8:  MOVLB  00
06A9:  CALL   643
06AA:  MOVLB  03
06AB:  MOVF   6B,W
06AC:  MOVWF  11
06AD:  MOVF   6C,W
06AE:  MOVWF  12
06AF:  MOVF   0B,W
06B0:  BCF    0B.7
06B1:  BSF    15.7
06B2:  BSF    15.0
06B3:  NOP
06B4:  NOP
06B5:  BTFSC  09.7
06B6:  BSF    0B.7
06B7:  RLF    13,W
06B8:  RLF    14,W
06B9:  ANDLW  7F
06BA:  BTFSC  03.2
06BB:  GOTO   6D0
06BC:  MOVWF  6A
06BD:  MOVF   11,W
06BE:  MOVWF  6B
06BF:  MOVF   12,W
06C0:  MOVWF  6C
06C1:  MOVF   6A,W
06C2:  MOVWF  6D
06C3:  MOVLB  00
06C4:  CALL   643
06C5:  MOVLB  03
06C6:  MOVF   6B,W
06C7:  MOVWF  11
06C8:  MOVF   6C,W
06C9:  MOVWF  12
06CA:  INCF   11,F
06CB:  BTFSC  03.2
06CC:  INCF   12,F
06CD:  MOVLB  00
06CE:  GOTO   694
06CF:  MOVLB  03
06D0:  MOVLB  00
06D1:  RETURN
....................  
.................... #list 
....................  
.................... #device ADC=10 
.................... #device PASS_STRINGS=IN_RAM 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOMCLR                   //Master Clear pin used for I/O 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
....................  
.................... #use delay(clock=48MHz,crystal=16MHz,USB_FULL) 
*
0CD5:  MOVLW  21
0CD6:  MOVWF  05
0CD7:  MOVLW  38
0CD8:  MOVWF  04
0CD9:  MOVF   00,W
0CDA:  BTFSC  03.2
0CDB:  GOTO   4EA
0CDC:  MOVLW  0F
0CDD:  MOVWF  78
0CDE:  CLRF   77
0CDF:  DECFSZ 77,F
0CE0:  GOTO   4DF
0CE1:  DECFSZ 78,F
0CE2:  GOTO   4DE
0CE3:  MOVLW  8F
0CE4:  MOVWF  77
0CE5:  DECFSZ 77,F
0CE6:  GOTO   4E5
0CE7:  NOP
0CE8:  DECFSZ 00,F
0CE9:  GOTO   4DC
.................... #use rs232(baud=9600,parity=N,UART1,bits=8,errors) 
*
05E8:  BTFSS  11.4
05E9:  GOTO   5E8
05EA:  MOVLB  03
05EB:  MOVWF  1A
05EC:  MOVLB  00
05ED:  RETURN
*
06D2:  BTFSS  11.5
06D3:  GOTO   6D2
06D4:  MOVLB  03
06D5:  MOVF   1D,W
06D6:  MOVWF  70
06D7:  MOVF   19,W
06D8:  MOVWF  78
06D9:  BTFSS  70.1
06DA:  GOTO   6DD
06DB:  BCF    1D.4
06DC:  BSF    1D.4
06DD:  MOVLP  00
06DE:  MOVLB  00
06DF:  GOTO   74B (RETURN)
*
103F:  MOVLB  04
1040:  CLRF   3C
1041:  MOVLB  03
1042:  MOVF   63,W
1043:  MOVLB  04
1044:  MOVWF  51
1045:  MOVLB  03
1046:  MOVF   62,W
1047:  MOVLB  04
1048:  MOVWF  50
1049:  MOVLB  03
104A:  MOVF   61,W
104B:  MOVLB  04
104C:  MOVWF  4F
104D:  MOVLB  03
104E:  MOVF   60,W
104F:  MOVLB  04
1050:  MOVWF  4E
1051:  CLRF   55
1052:  CLRF   54
1053:  CLRF   53
1054:  MOVLW  40
1055:  MOVWF  52
1056:  MOVLP  00
1057:  MOVLB  00
1058:  CALL   54B
1059:  MOVLP  10
105A:  MOVLB  03
105B:  MOVF   67,W
105C:  MOVLB  04
105D:  MOVWF  51
105E:  MOVLB  03
105F:  MOVF   66,W
1060:  MOVLB  04
1061:  MOVWF  50
1062:  MOVLB  03
1063:  MOVF   65,W
1064:  MOVLB  04
1065:  MOVWF  4F
1066:  MOVLB  03
1067:  MOVF   64,W
1068:  MOVLB  04
1069:  MOVWF  4E
106A:  MOVF   7A,W
106B:  MOVWF  55
106C:  MOVF   79,W
106D:  MOVWF  54
106E:  MOVF   78,W
106F:  MOVWF  53
1070:  MOVF   77,W
1071:  MOVWF  52
1072:  MOVLP  00
1073:  MOVLB  00
1074:  CALL   577
1075:  MOVLP  10
1076:  MOVF   7A,W
1077:  MOVLB  04
1078:  MOVWF  2F
1079:  MOVF   79,W
107A:  MOVWF  2E
107B:  MOVF   78,W
107C:  MOVWF  2D
107D:  MOVF   77,W
107E:  MOVWF  2C
107F:  MOVLW  FF
1080:  ADDWF  2C,F
1081:  BTFSS  03.0
1082:  ADDWF  2D,F
1083:  BTFSS  03.0
1084:  ADDWF  2E,F
1085:  BTFSS  03.0
1086:  ADDWF  2F,F
1087:  MOVF   2F,F
1088:  BTFSS  03.2
1089:  GOTO   091
108A:  MOVF   2E,F
108B:  BTFSS  03.2
108C:  GOTO   091
108D:  MOVF   2D,W
108E:  SUBLW  00
108F:  BTFSC  03.0
1090:  GOTO   096
1091:  CLRF   2F
1092:  CLRF   2E
1093:  CLRF   2D
1094:  MOVLW  FF
1095:  MOVWF  2C
1096:  MOVLW  01
1097:  ADDWF  2C,W
1098:  MOVWF  77
1099:  MOVLW  00
109A:  ADDWFC 2D,W
109B:  MOVWF  78
109C:  MOVLW  00
109D:  ADDWFC 2E,W
109E:  MOVWF  79
109F:  MOVLW  00
10A0:  ADDWFC 2F,W
10A1:  MOVWF  7A
10A2:  MOVF   7A,W
10A3:  MOVWF  51
10A4:  MOVF   79,W
10A5:  MOVWF  50
10A6:  MOVF   78,W
10A7:  MOVWF  4F
10A8:  MOVF   77,W
10A9:  MOVWF  4E
10AA:  CLRF   55
10AB:  CLRF   54
10AC:  CLRF   53
10AD:  MOVLW  40
10AE:  MOVWF  52
10AF:  MOVLP  00
10B0:  MOVLB  00
10B1:  CALL   54B
10B2:  MOVLP  10
10B3:  MOVLB  03
10B4:  MOVF   67,W
10B5:  MOVLB  04
10B6:  MOVWF  51
10B7:  MOVLB  03
10B8:  MOVF   66,W
10B9:  MOVLB  04
10BA:  MOVWF  50
10BB:  MOVLB  03
10BC:  MOVF   65,W
10BD:  MOVLB  04
10BE:  MOVWF  4F
10BF:  MOVLB  03
10C0:  MOVF   64,W
10C1:  MOVLB  04
10C2:  MOVWF  4E
10C3:  MOVF   7A,W
10C4:  MOVWF  55
10C5:  MOVF   79,W
10C6:  MOVWF  54
10C7:  MOVF   78,W
10C8:  MOVWF  53
10C9:  MOVF   77,W
10CA:  MOVWF  52
10CB:  MOVLP  00
10CC:  MOVLB  00
10CD:  CALL   577
10CE:  MOVLP  10
10CF:  MOVF   7A,W
10D0:  MOVLB  03
10D1:  SUBWF  63,W
10D2:  BTFSS  03.0
10D3:  GOTO   0E6
10D4:  BTFSS  03.2
10D5:  GOTO   0FB
10D6:  MOVF   79,W
10D7:  SUBWF  62,W
10D8:  BTFSS  03.0
10D9:  GOTO   0E6
10DA:  BTFSS  03.2
10DB:  GOTO   0FB
10DC:  MOVF   78,W
10DD:  SUBWF  61,W
10DE:  BTFSS  03.0
10DF:  GOTO   0E6
10E0:  BTFSS  03.2
10E1:  GOTO   0FB
10E2:  MOVF   77,W
10E3:  SUBWF  60,W
10E4:  BTFSC  03.0
10E5:  GOTO   0FB
10E6:  MOVF   60,W
10E7:  SUBWF  77,W
10E8:  MOVLB  04
10E9:  MOVWF  34
10EA:  MOVLB  03
10EB:  MOVF   61,W
10EC:  SUBWFC 78,W
10ED:  MOVLB  04
10EE:  MOVWF  35
10EF:  MOVLB  03
10F0:  MOVF   62,W
10F1:  SUBWFC 79,W
10F2:  MOVLB  04
10F3:  MOVWF  36
10F4:  MOVLB  03
10F5:  MOVF   63,W
10F6:  SUBWFC 7A,W
10F7:  MOVLB  04
10F8:  MOVWF  37
10F9:  GOTO   10E
10FA:  MOVLB  03
10FB:  MOVF   77,W
10FC:  SUBWF  60,W
10FD:  MOVLB  04
10FE:  MOVWF  34
10FF:  MOVF   78,W
1100:  MOVLB  03
1101:  SUBWFC 61,W
1102:  MOVLB  04
1103:  MOVWF  35
1104:  MOVF   79,W
1105:  MOVLB  03
1106:  SUBWFC 62,W
1107:  MOVLB  04
1108:  MOVWF  36
1109:  MOVF   7A,W
110A:  MOVLB  03
110B:  SUBWFC 63,W
110C:  MOVLB  04
110D:  MOVWF  37
110E:  MOVLB  03
110F:  MOVF   63,W
1110:  MOVLB  04
1111:  MOVWF  51
1112:  MOVLB  03
1113:  MOVF   62,W
1114:  MOVLB  04
1115:  MOVWF  50
1116:  MOVLB  03
1117:  MOVF   61,W
1118:  MOVLB  04
1119:  MOVWF  4F
111A:  MOVLB  03
111B:  MOVF   60,W
111C:  MOVLB  04
111D:  MOVWF  4E
111E:  CLRF   55
111F:  CLRF   54
1120:  CLRF   53
1121:  MOVLW  10
1122:  MOVWF  52
1123:  MOVLP  00
1124:  MOVLB  00
1125:  CALL   54B
1126:  MOVLP  10
1127:  MOVLB  03
1128:  MOVF   67,W
1129:  MOVLB  04
112A:  MOVWF  51
112B:  MOVLB  03
112C:  MOVF   66,W
112D:  MOVLB  04
112E:  MOVWF  50
112F:  MOVLB  03
1130:  MOVF   65,W
1131:  MOVLB  04
1132:  MOVWF  4F
1133:  MOVLB  03
1134:  MOVF   64,W
1135:  MOVLB  04
1136:  MOVWF  4E
1137:  MOVF   7A,W
1138:  MOVWF  55
1139:  MOVF   79,W
113A:  MOVWF  54
113B:  MOVF   78,W
113C:  MOVWF  53
113D:  MOVF   77,W
113E:  MOVWF  52
113F:  MOVLP  00
1140:  MOVLB  00
1141:  CALL   577
1142:  MOVLP  10
1143:  MOVF   7A,W
1144:  MOVLB  04
1145:  MOVWF  33
1146:  MOVF   79,W
1147:  MOVWF  32
1148:  MOVF   78,W
1149:  MOVWF  31
114A:  MOVF   77,W
114B:  MOVWF  30
114C:  MOVLW  FF
114D:  ADDWF  30,F
114E:  BTFSS  03.0
114F:  ADDWF  31,F
1150:  BTFSS  03.0
1151:  ADDWF  32,F
1152:  BTFSS  03.0
1153:  ADDWF  33,F
1154:  MOVF   33,F
1155:  BTFSS  03.2
1156:  GOTO   15E
1157:  MOVF   32,F
1158:  BTFSS  03.2
1159:  GOTO   15E
115A:  MOVF   31,W
115B:  SUBLW  00
115C:  BTFSC  03.0
115D:  GOTO   163
115E:  CLRF   33
115F:  CLRF   32
1160:  CLRF   31
1161:  MOVLW  FF
1162:  MOVWF  30
1163:  MOVLW  01
1164:  ADDWF  30,W
1165:  MOVWF  77
1166:  MOVLW  00
1167:  ADDWFC 31,W
1168:  MOVWF  78
1169:  MOVLW  00
116A:  ADDWFC 32,W
116B:  MOVWF  79
116C:  MOVLW  00
116D:  ADDWFC 33,W
116E:  MOVWF  7A
116F:  MOVF   7A,W
1170:  MOVWF  51
1171:  MOVF   79,W
1172:  MOVWF  50
1173:  MOVF   78,W
1174:  MOVWF  4F
1175:  MOVF   77,W
1176:  MOVWF  4E
1177:  CLRF   55
1178:  CLRF   54
1179:  CLRF   53
117A:  MOVLW  10
117B:  MOVWF  52
117C:  MOVLP  00
117D:  MOVLB  00
117E:  CALL   54B
117F:  MOVLP  10
1180:  MOVLB  03
1181:  MOVF   67,W
1182:  MOVLB  04
1183:  MOVWF  51
1184:  MOVLB  03
1185:  MOVF   66,W
1186:  MOVLB  04
1187:  MOVWF  50
1188:  MOVLB  03
1189:  MOVF   65,W
118A:  MOVLB  04
118B:  MOVWF  4F
118C:  MOVLB  03
118D:  MOVF   64,W
118E:  MOVLB  04
118F:  MOVWF  4E
1190:  MOVF   7A,W
1191:  MOVWF  55
1192:  MOVF   79,W
1193:  MOVWF  54
1194:  MOVF   78,W
1195:  MOVWF  53
1196:  MOVF   77,W
1197:  MOVWF  52
1198:  MOVLP  00
1199:  MOVLB  00
119A:  CALL   577
119B:  MOVLP  10
119C:  MOVF   7A,W
119D:  MOVLB  03
119E:  SUBWF  63,W
119F:  BTFSS  03.0
11A0:  GOTO   1B3
11A1:  BTFSS  03.2
11A2:  GOTO   1C8
11A3:  MOVF   79,W
11A4:  SUBWF  62,W
11A5:  BTFSS  03.0
11A6:  GOTO   1B3
11A7:  BTFSS  03.2
11A8:  GOTO   1C8
11A9:  MOVF   78,W
11AA:  SUBWF  61,W
11AB:  BTFSS  03.0
11AC:  GOTO   1B3
11AD:  BTFSS  03.2
11AE:  GOTO   1C8
11AF:  MOVF   77,W
11B0:  SUBWF  60,W
11B1:  BTFSC  03.0
11B2:  GOTO   1C8
11B3:  MOVF   60,W
11B4:  SUBWF  77,W
11B5:  MOVLB  04
11B6:  MOVWF  38
11B7:  MOVLB  03
11B8:  MOVF   61,W
11B9:  SUBWFC 78,W
11BA:  MOVLB  04
11BB:  MOVWF  39
11BC:  MOVLB  03
11BD:  MOVF   62,W
11BE:  SUBWFC 79,W
11BF:  MOVLB  04
11C0:  MOVWF  3A
11C1:  MOVLB  03
11C2:  MOVF   63,W
11C3:  SUBWFC 7A,W
11C4:  MOVLB  04
11C5:  MOVWF  3B
11C6:  GOTO   1DB
11C7:  MOVLB  03
11C8:  MOVF   77,W
11C9:  SUBWF  60,W
11CA:  MOVLB  04
11CB:  MOVWF  38
11CC:  MOVF   78,W
11CD:  MOVLB  03
11CE:  SUBWFC 61,W
11CF:  MOVLB  04
11D0:  MOVWF  39
11D1:  MOVF   79,W
11D2:  MOVLB  03
11D3:  SUBWFC 62,W
11D4:  MOVLB  04
11D5:  MOVWF  3A
11D6:  MOVF   7A,W
11D7:  MOVLB  03
11D8:  SUBWFC 63,W
11D9:  MOVLB  04
11DA:  MOVWF  3B
11DB:  MOVF   37,W
11DC:  SUBWF  3B,W
11DD:  BTFSS  03.0
11DE:  GOTO   1F1
11DF:  BTFSS  03.2
11E0:  GOTO   1FF
11E1:  MOVF   36,W
11E2:  SUBWF  3A,W
11E3:  BTFSS  03.0
11E4:  GOTO   1F1
11E5:  BTFSS  03.2
11E6:  GOTO   1FF
11E7:  MOVF   35,W
11E8:  SUBWF  39,W
11E9:  BTFSS  03.0
11EA:  GOTO   1F1
11EB:  BTFSS  03.2
11EC:  GOTO   1FF
11ED:  MOVF   38,W
11EE:  SUBWF  34,W
11EF:  BTFSS  03.0
11F0:  GOTO   1FF
11F1:  MOVLW  01
11F2:  MOVWF  3C
11F3:  MOVF   31,W
11F4:  MOVWF  2D
11F5:  MOVF   30,W
11F6:  MOVWF  2C
11F7:  MOVF   3B,W
11F8:  MOVWF  37
11F9:  MOVF   3A,W
11FA:  MOVWF  36
11FB:  MOVF   39,W
11FC:  MOVWF  35
11FD:  MOVF   38,W
11FE:  MOVWF  34
11FF:  MOVLB  03
1200:  MOVF   63,W
1201:  MOVLB  04
1202:  MOVWF  51
1203:  MOVLB  03
1204:  MOVF   62,W
1205:  MOVLB  04
1206:  MOVWF  50
1207:  MOVLB  03
1208:  MOVF   61,W
1209:  MOVLB  04
120A:  MOVWF  4F
120B:  MOVLB  03
120C:  MOVF   60,W
120D:  MOVLB  04
120E:  MOVWF  4E
120F:  CLRF   55
1210:  CLRF   54
1211:  CLRF   53
1212:  MOVLW  10
1213:  MOVWF  52
1214:  MOVLP  00
1215:  MOVLB  00
1216:  CALL   54B
1217:  MOVLP  10
1218:  MOVLB  03
1219:  MOVF   67,W
121A:  MOVLB  04
121B:  MOVWF  51
121C:  MOVLB  03
121D:  MOVF   66,W
121E:  MOVLB  04
121F:  MOVWF  50
1220:  MOVLB  03
1221:  MOVF   65,W
1222:  MOVLB  04
1223:  MOVWF  4F
1224:  MOVLB  03
1225:  MOVF   64,W
1226:  MOVLB  04
1227:  MOVWF  4E
1228:  MOVF   7A,W
1229:  MOVWF  55
122A:  MOVF   79,W
122B:  MOVWF  54
122C:  MOVF   78,W
122D:  MOVWF  53
122E:  MOVF   77,W
122F:  MOVWF  52
1230:  MOVLP  00
1231:  MOVLB  00
1232:  CALL   577
1233:  MOVLP  10
1234:  MOVF   7A,W
1235:  MOVLB  04
1236:  MOVWF  33
1237:  MOVF   79,W
1238:  MOVWF  32
1239:  MOVF   78,W
123A:  MOVWF  31
123B:  MOVF   77,W
123C:  MOVWF  30
123D:  MOVLW  FF
123E:  ADDWF  30,F
123F:  BTFSS  03.0
1240:  ADDWF  31,F
1241:  BTFSS  03.0
1242:  ADDWF  32,F
1243:  BTFSS  03.0
1244:  ADDWF  33,F
1245:  MOVF   33,F
1246:  BTFSS  03.2
1247:  GOTO   24C
1248:  MOVF   32,W
1249:  SUBLW  00
124A:  BTFSC  03.0
124B:  GOTO   252
124C:  CLRF   33
124D:  CLRF   32
124E:  MOVLW  FF
124F:  MOVWF  31
1250:  MOVLW  FF
1251:  MOVWF  30
1252:  MOVLW  01
1253:  ADDWF  30,W
1254:  MOVWF  77
1255:  MOVLW  00
1256:  ADDWFC 31,W
1257:  MOVWF  78
1258:  MOVLW  00
1259:  ADDWFC 32,W
125A:  MOVWF  79
125B:  MOVLW  00
125C:  ADDWFC 33,W
125D:  MOVWF  7A
125E:  MOVF   7A,W
125F:  MOVWF  51
1260:  MOVF   79,W
1261:  MOVWF  50
1262:  MOVF   78,W
1263:  MOVWF  4F
1264:  MOVF   77,W
1265:  MOVWF  4E
1266:  CLRF   55
1267:  CLRF   54
1268:  CLRF   53
1269:  MOVLW  10
126A:  MOVWF  52
126B:  MOVLP  00
126C:  MOVLB  00
126D:  CALL   54B
126E:  MOVLP  10
126F:  MOVLB  03
1270:  MOVF   67,W
1271:  MOVLB  04
1272:  MOVWF  51
1273:  MOVLB  03
1274:  MOVF   66,W
1275:  MOVLB  04
1276:  MOVWF  50
1277:  MOVLB  03
1278:  MOVF   65,W
1279:  MOVLB  04
127A:  MOVWF  4F
127B:  MOVLB  03
127C:  MOVF   64,W
127D:  MOVLB  04
127E:  MOVWF  4E
127F:  MOVF   7A,W
1280:  MOVWF  55
1281:  MOVF   79,W
1282:  MOVWF  54
1283:  MOVF   78,W
1284:  MOVWF  53
1285:  MOVF   77,W
1286:  MOVWF  52
1287:  MOVLP  00
1288:  MOVLB  00
1289:  CALL   577
128A:  MOVLP  10
128B:  MOVF   7A,W
128C:  MOVLB  03
128D:  SUBWF  63,W
128E:  BTFSS  03.0
128F:  GOTO   2A2
1290:  BTFSS  03.2
1291:  GOTO   2B7
1292:  MOVF   79,W
1293:  SUBWF  62,W
1294:  BTFSS  03.0
1295:  GOTO   2A2
1296:  BTFSS  03.2
1297:  GOTO   2B7
1298:  MOVF   78,W
1299:  SUBWF  61,W
129A:  BTFSS  03.0
129B:  GOTO   2A2
129C:  BTFSS  03.2
129D:  GOTO   2B7
129E:  MOVF   77,W
129F:  SUBWF  60,W
12A0:  BTFSC  03.0
12A1:  GOTO   2B7
12A2:  MOVF   60,W
12A3:  SUBWF  77,W
12A4:  MOVLB  04
12A5:  MOVWF  38
12A6:  MOVLB  03
12A7:  MOVF   61,W
12A8:  SUBWFC 78,W
12A9:  MOVLB  04
12AA:  MOVWF  39
12AB:  MOVLB  03
12AC:  MOVF   62,W
12AD:  SUBWFC 79,W
12AE:  MOVLB  04
12AF:  MOVWF  3A
12B0:  MOVLB  03
12B1:  MOVF   63,W
12B2:  SUBWFC 7A,W
12B3:  MOVLB  04
12B4:  MOVWF  3B
12B5:  GOTO   2CA
12B6:  MOVLB  03
12B7:  MOVF   77,W
12B8:  SUBWF  60,W
12B9:  MOVLB  04
12BA:  MOVWF  38
12BB:  MOVF   78,W
12BC:  MOVLB  03
12BD:  SUBWFC 61,W
12BE:  MOVLB  04
12BF:  MOVWF  39
12C0:  MOVF   79,W
12C1:  MOVLB  03
12C2:  SUBWFC 62,W
12C3:  MOVLB  04
12C4:  MOVWF  3A
12C5:  MOVF   7A,W
12C6:  MOVLB  03
12C7:  SUBWFC 63,W
12C8:  MOVLB  04
12C9:  MOVWF  3B
12CA:  MOVF   37,W
12CB:  SUBWF  3B,W
12CC:  BTFSS  03.0
12CD:  GOTO   2E0
12CE:  BTFSS  03.2
12CF:  GOTO   2F0
12D0:  MOVF   36,W
12D1:  SUBWF  3A,W
12D2:  BTFSS  03.0
12D3:  GOTO   2E0
12D4:  BTFSS  03.2
12D5:  GOTO   2F0
12D6:  MOVF   35,W
12D7:  SUBWF  39,W
12D8:  BTFSS  03.0
12D9:  GOTO   2E0
12DA:  BTFSS  03.2
12DB:  GOTO   2F0
12DC:  MOVF   38,W
12DD:  SUBWF  34,W
12DE:  BTFSS  03.0
12DF:  GOTO   2F0
12E0:  MOVLW  02
12E1:  MOVWF  3C
12E2:  CLRF   2F
12E3:  CLRF   2E
12E4:  MOVF   31,W
12E5:  MOVWF  2D
12E6:  MOVF   30,W
12E7:  MOVWF  2C
12E8:  MOVF   3B,W
12E9:  MOVWF  37
12EA:  MOVF   3A,W
12EB:  MOVWF  36
12EC:  MOVF   39,W
12ED:  MOVWF  35
12EE:  MOVF   38,W
12EF:  MOVWF  34
12F0:  MOVLB  03
12F1:  MOVF   63,W
12F2:  MOVLB  04
12F3:  MOVWF  51
12F4:  MOVLB  03
12F5:  MOVF   62,W
12F6:  MOVLB  04
12F7:  MOVWF  50
12F8:  MOVLB  03
12F9:  MOVF   61,W
12FA:  MOVLB  04
12FB:  MOVWF  4F
12FC:  MOVLB  03
12FD:  MOVF   60,W
12FE:  MOVLB  04
12FF:  MOVWF  4E
1300:  CLRF   55
1301:  CLRF   54
1302:  CLRF   53
1303:  MOVLW  04
1304:  MOVWF  52
1305:  MOVLP  00
1306:  MOVLB  00
1307:  CALL   54B
1308:  MOVLP  10
1309:  MOVLB  03
130A:  MOVF   67,W
130B:  MOVLB  04
130C:  MOVWF  51
130D:  MOVLB  03
130E:  MOVF   66,W
130F:  MOVLB  04
1310:  MOVWF  50
1311:  MOVLB  03
1312:  MOVF   65,W
1313:  MOVLB  04
1314:  MOVWF  4F
1315:  MOVLB  03
1316:  MOVF   64,W
1317:  MOVLB  04
1318:  MOVWF  4E
1319:  MOVF   7A,W
131A:  MOVWF  55
131B:  MOVF   79,W
131C:  MOVWF  54
131D:  MOVF   78,W
131E:  MOVWF  53
131F:  MOVF   77,W
1320:  MOVWF  52
1321:  MOVLP  00
1322:  MOVLB  00
1323:  CALL   577
1324:  MOVLP  10
1325:  MOVF   7A,W
1326:  MOVLB  04
1327:  MOVWF  33
1328:  MOVF   79,W
1329:  MOVWF  32
132A:  MOVF   78,W
132B:  MOVWF  31
132C:  MOVF   77,W
132D:  MOVWF  30
132E:  MOVLW  FF
132F:  ADDWF  30,F
1330:  BTFSS  03.0
1331:  ADDWF  31,F
1332:  BTFSS  03.0
1333:  ADDWF  32,F
1334:  BTFSS  03.0
1335:  ADDWF  33,F
1336:  MOVF   33,F
1337:  BTFSS  03.2
1338:  GOTO   33D
1339:  MOVF   32,W
133A:  SUBLW  00
133B:  BTFSC  03.0
133C:  GOTO   343
133D:  CLRF   33
133E:  CLRF   32
133F:  MOVLW  FF
1340:  MOVWF  31
1341:  MOVLW  FF
1342:  MOVWF  30
1343:  MOVLW  01
1344:  ADDWF  30,W
1345:  MOVWF  77
1346:  MOVLW  00
1347:  ADDWFC 31,W
1348:  MOVWF  78
1349:  MOVLW  00
134A:  ADDWFC 32,W
134B:  MOVWF  79
134C:  MOVLW  00
134D:  ADDWFC 33,W
134E:  MOVWF  7A
134F:  MOVF   7A,W
1350:  MOVWF  51
1351:  MOVF   79,W
1352:  MOVWF  50
1353:  MOVF   78,W
1354:  MOVWF  4F
1355:  MOVF   77,W
1356:  MOVWF  4E
1357:  CLRF   55
1358:  CLRF   54
1359:  CLRF   53
135A:  MOVLW  04
135B:  MOVWF  52
135C:  MOVLP  00
135D:  MOVLB  00
135E:  CALL   54B
135F:  MOVLP  10
1360:  MOVLB  03
1361:  MOVF   67,W
1362:  MOVLB  04
1363:  MOVWF  51
1364:  MOVLB  03
1365:  MOVF   66,W
1366:  MOVLB  04
1367:  MOVWF  50
1368:  MOVLB  03
1369:  MOVF   65,W
136A:  MOVLB  04
136B:  MOVWF  4F
136C:  MOVLB  03
136D:  MOVF   64,W
136E:  MOVLB  04
136F:  MOVWF  4E
1370:  MOVF   7A,W
1371:  MOVWF  55
1372:  MOVF   79,W
1373:  MOVWF  54
1374:  MOVF   78,W
1375:  MOVWF  53
1376:  MOVF   77,W
1377:  MOVWF  52
1378:  MOVLP  00
1379:  MOVLB  00
137A:  CALL   577
137B:  MOVLP  10
137C:  MOVF   7A,W
137D:  MOVLB  03
137E:  SUBWF  63,W
137F:  BTFSS  03.0
1380:  GOTO   393
1381:  BTFSS  03.2
1382:  GOTO   3A8
1383:  MOVF   79,W
1384:  SUBWF  62,W
1385:  BTFSS  03.0
1386:  GOTO   393
1387:  BTFSS  03.2
1388:  GOTO   3A8
1389:  MOVF   78,W
138A:  SUBWF  61,W
138B:  BTFSS  03.0
138C:  GOTO   393
138D:  BTFSS  03.2
138E:  GOTO   3A8
138F:  MOVF   77,W
1390:  SUBWF  60,W
1391:  BTFSC  03.0
1392:  GOTO   3A8
1393:  MOVF   60,W
1394:  SUBWF  77,W
1395:  MOVLB  04
1396:  MOVWF  38
1397:  MOVLB  03
1398:  MOVF   61,W
1399:  SUBWFC 78,W
139A:  MOVLB  04
139B:  MOVWF  39
139C:  MOVLB  03
139D:  MOVF   62,W
139E:  SUBWFC 79,W
139F:  MOVLB  04
13A0:  MOVWF  3A
13A1:  MOVLB  03
13A2:  MOVF   63,W
13A3:  SUBWFC 7A,W
13A4:  MOVLB  04
13A5:  MOVWF  3B
13A6:  GOTO   3BB
13A7:  MOVLB  03
13A8:  MOVF   77,W
13A9:  SUBWF  60,W
13AA:  MOVLB  04
13AB:  MOVWF  38
13AC:  MOVF   78,W
13AD:  MOVLB  03
13AE:  SUBWFC 61,W
13AF:  MOVLB  04
13B0:  MOVWF  39
13B1:  MOVF   79,W
13B2:  MOVLB  03
13B3:  SUBWFC 62,W
13B4:  MOVLB  04
13B5:  MOVWF  3A
13B6:  MOVF   7A,W
13B7:  MOVLB  03
13B8:  SUBWFC 63,W
13B9:  MOVLB  04
13BA:  MOVWF  3B
13BB:  MOVF   37,W
13BC:  SUBWF  3B,W
13BD:  BTFSS  03.0
13BE:  GOTO   3D1
13BF:  BTFSS  03.2
13C0:  GOTO   3D7
13C1:  MOVF   36,W
13C2:  SUBWF  3A,W
13C3:  BTFSS  03.0
13C4:  GOTO   3D1
13C5:  BTFSS  03.2
13C6:  GOTO   3D7
13C7:  MOVF   35,W
13C8:  SUBWF  39,W
13C9:  BTFSS  03.0
13CA:  GOTO   3D1
13CB:  BTFSS  03.2
13CC:  GOTO   3D7
13CD:  MOVF   38,W
13CE:  SUBWF  34,W
13CF:  BTFSS  03.0
13D0:  GOTO   3D7
13D1:  MOVLW  03
13D2:  MOVWF  3C
13D3:  MOVF   31,W
13D4:  MOVWF  2D
13D5:  MOVF   30,W
13D6:  MOVWF  2C
13D7:  BTFSS  3C.1
13D8:  GOTO   3DC
13D9:  MOVLB  03
13DA:  BSF    1F.3
13DB:  MOVLB  04
13DC:  BTFSC  3C.1
13DD:  GOTO   3E1
13DE:  MOVLB  03
13DF:  BCF    1F.3
13E0:  MOVLB  04
13E1:  MOVF   2C,W
13E2:  MOVLB  03
13E3:  MOVWF  1B
13E4:  MOVLB  04
13E5:  MOVF   2D,W
13E6:  MOVLB  03
13E7:  MOVWF  1C
13E8:  MOVLW  A2
13E9:  MOVWF  1E
13EA:  MOVLB  04
13EB:  BTFSS  3C.0
13EC:  GOTO   3F0
13ED:  MOVLB  03
13EE:  BSF    1E.2
13EF:  MOVLB  04
13F0:  MOVLW  90
13F1:  MOVLB  03
13F2:  MOVWF  1D
....................  
....................  
.................... #use FIXED_IO( C_outputs=PIN_C4,PIN_C3,PIN_C2,PIN_C1 ) 
.................... #define RESET1938       PIN_C1 
.................... #define LEDTX           PIN_C2 
.................... #define LEDRX           PIN_C3 
....................  
.................... #define USB_CONFIG_VID 0x0461 
.................... #define USB_CONFIG_PID 0x0003 
.................... #define USB_CONFIG_BUS_POWER 500 
.................... #define USB_STRINGS_OVERWRITTEN 
....................  
.................... char const USB_STRING_DESC[]={ 
....................    //string 0 - language 
....................       4,  //length of string index 
....................       0x03,  //descriptor type (STRING) 
....................       0x09,0x04,  //Microsoft Defined for US-English 
....................    //string 1 - manufacturer 
....................       16,  //length of string index 
....................       0x03,  //descriptor type (STRING) 
....................       'B',0, 
....................       'a',0, 
....................       'b',0, 
....................       'u',0, 
....................       'I',0, 
....................       'N',0, 
....................       'O',0, 
....................    //string 2 - product 
....................       24,  //length of string index 
....................       0x03,  //descriptor type (STRING) 
....................       'B',0, 
....................       'a',0, 
....................       'b',0, 
....................       'u',0, 
....................       'I',0, 
....................       'N',0, 
....................       'O',0, 
....................       ' ',0, 
....................       'U',0, 
....................       'N',0, 
....................       'O',0 
.................... }; 
....................  
.................... #include <usb_cdc.h> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////                            usb_cdc.h                            //// 
.................... ////                                                                 //// 
.................... //// Library for adding a virtual COM port on your PC over USB using //// 
.................... //// the standard Communication Device Class (CDC) specification.    //// 
.................... //// Including this file in your code will add all USB code,         //// 
.................... //// interrupts, descriptors and handlers required.  No other        //// 
.................... //// modifications need to be made.                                  //// 
.................... ////                                                                 //// 
.................... //// This library creates a virtual RS232 link between the PC and    //// 
.................... //// the PIC, therefore the library provided will be familiar to     //// 
.................... //// anyone with standard UART stream I/O:                           //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_kbhit() - Returns TRUE if there is one or more          //// 
.................... ////      character received and waiting in the receive buffer.      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_getc() - Gets a character from the receive buffer.  If  //// 
.................... ////      there is no data in the receive buffer it will wait until  //// 
.................... ////      there is data in the receive buffer.  If you do not want   //// 
.................... ////      to wait in an infinit loop, use usb_cdc_kbhit() first to   //// 
.................... ////      check if there is data before calling usb_cdc_getc().      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putc(char c) - Puts a character into the transmit       //// 
.................... ////      buffer.  If the transmit buffer is full it will wait until //// 
.................... ////      the transmit buffer is not full before putting the char    //// 
.................... ////      into the transmit buffer.  The transmit buffer is read by  //// 
.................... ////      the PC very quickly, and therefore the buffer should only  //// 
.................... ////      be full for a few milli-seconds.  If you are concerned     //// 
.................... ////      and don't want to be stuck in a long or infinite loop,     //// 
.................... ////      use usb_cdc_putready() to see if there is space in the     //// 
.................... ////      transmit buffer before putting data into the transmit      //// 
.................... ////      buffer.                                                    //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_puts(*ptr) - Sends the null terminated string to the    //// 
.................... ////     the transmit buffer.  Unlike usb_cdc_putc() or              //// 
.................... ////     usb_cdc_putc_fast(), this routine will fit the string in    //// 
.................... ////     one packet (whereas the other functions will flush the      //// 
.................... ////     buffer as soon as the endpoint is free).                    //// 
.................... ////     Returns TRUE if the packet was sent, FALSE if the buffer    //// 
.................... ////     was still in use.                                           //// 
.................... ////     Will stop copying characters from ptr to the endpoint       //// 
.................... ////     buffer once it is full (but it will still return TRUE).     //// 
.................... ////     'ptr' needs to be smaller than the transmit buffer.         //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putd(*ptr, len) - Sends 'len' byte from 'ptr' to the    //// 
.................... ////     transmit buffer.  Unlike usb_cdc_putc() or                  //// 
.................... ////     usb_cdc_putc_fast(), this routine will fit the string in    //// 
.................... ////     one packet (whereas the other functions will flush the      //// 
.................... ////     buffer as soon as the endpoint is free).                    //// 
.................... ////     Returns TRUE if the packet was sent, FALSE if the buffer    //// 
.................... ////     was still in use.                                           //// 
.................... ////     Will stop copying characters from ptr to the endpoint       //// 
.................... ////     buffer once it is full (but it will still return TRUE).     //// 
.................... ////     'len' needs to be smaller than the transmit buffer.         //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putready() - Returns the number of bytes available      //// 
.................... ////     in the TX buffer for storing characters.  If this returns   //// 
.................... ////     0 then the buffer is full and waiting for the host (PC)     //// 
.................... ////     to read the buffer.                                         //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putempty() - Returns TRUE if the transmit buffers are   //// 
.................... ////     empty and fully flushed/transmitted to host (PC).           //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_connected() - Returns TRUE if we received a             //// 
.................... ////      Set_Line_Coding.  On most serial terminal programs (such   //// 
.................... ////      as Hyperterminal), they will send a Set_Line_Coding        //// 
.................... ////      message when the program starts and it opens the virtual   //// 
.................... ////      COM port.  This is a simple way to determine if the PC     //// 
.................... ////      is ready to display data on a serial terminal program,     //// 
.................... ////      but is not garaunteed to work all the time or on other     //// 
.................... ////      terminal programs.                                         //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putc_fast(char c) - Similar to usb_cdc_putc(), except   //// 
.................... ////      if the transmit buffer is full it will skip the char.      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_line_coding - A structure used for Set_Line_Coding and  //// 
.................... ////       Get_Line_Coding.  Most of the time you can ignore this.   //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_break - If the PC has sent a break command, this will   //// 
.................... ////       hold the break time (in milli-seconds).  If the PC sends  //// 
.................... ////       a value of 0xFFFF the device is supposed to hold the      //// 
.................... ////       break until it sends a value of 0                         //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_carrier - Where Set_Control_Line_State value is stored. //// 
.................... ////       Of most relevance is the field dte_present, which is the  //// 
.................... ////       DTR setting.                                              //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_serial_state(state) - Transmit to the host our          //// 
.................... ////       SERIAL_STATE.  This holds information such as DCD, DSR,   //// 
.................... ////       ring, break and more.  See the documentation above        //// 
.................... ////       usb_cdc_serial_state() for more information, including    //// 
.................... ////       format of state structure.                                //// 
.................... ////                                                                 //// 
.................... //// The following functions are also provided, and are ports of the //// 
.................... //// I/O functions in input.c.  See input.c and the CCS manual for   //// 
.................... //// documentation:                                                  //// 
.................... ////   get_float_usb() - Read a float number from the user           //// 
.................... ////   get_long_usb() - Read a long number from the user             //// 
.................... ////   get_int_usb() - Read an integer number from the user          //// 
.................... ////   get_string_usb(char *s, int max) - Read a string from the user. //// 
.................... ////   gethex_usb() - Read a byte, in HEX, from the user             //// 
.................... ////   gethex1_usb() - Read a HEX character                          //// 
.................... ////                                                                 //// 
.................... //// USB_CDC_ISR() can be defined if you want a specific routine to  //// 
.................... //// be called when there is incoming CDC (virtual com port) data.   //// 
.................... //// This is useful if you want to update legacy RS232 code that     //// 
.................... //// was using #int_rda to handle incoming data in the RS232 ISR.    //// 
.................... //// However, see the INTERRUPT LIMITATIONS section below.           //// 
.................... ////                                                                 //// 
.................... //// Normally usb_cdc_putc() and usb_cdc_putc_fast() will attempt    //// 
.................... ////  to flush the data as soon as possible.  However at times       //// 
.................... ////  this can be ineffecient and flush a packet with only 1 byte.   //// 
.................... ////  The USB_CDC_DELAYED_FLUSH option will attempt to flush         //// 
.................... ////  at the beginning of usb_cdc_putc() and usb_cdc_putc_fast()     //// 
.................... ////  if the local buffer is full.  USB_CDC_DELAYED_FLUSH will       //// 
.................... ////  also attempt to flush the packet on each call to usb_task().   //// 
.................... ////  It is recommended to only use USB_CDC_DELAYED_FLUSH option     //// 
.................... ////  if you have a main loop that periodically calls usb_task().    //// 
.................... ////                                                                 //// 
.................... //// This driver will load all the rest of the USB code, and a set   //// 
.................... //// of descriptors that will properly describe a CDC device for a   //// 
.................... //// virtual COM port (usb_desc_cdc.h)                               //// 
.................... ////                                                                 //// 
.................... //// An .INF file is provided (cdc_NTXP.inf) that will load the      //// 
.................... //// standard CDC drivers for a virtual COM port in Windows          //// 
.................... //// NT/2000/XP and above.                                           //// 
.................... ////                                                                 //// 
.................... ////                                                                 //// 
.................... //// Encapsuated Messages: (USB_CDC_USE_ENCAPSULATED)                //// 
.................... //// -------------------------------------------------------------   //// 
.................... ////                                                                 //// 
.................... //// If USB_CDC_USE_ENCAPSULATED is defined, then the user must      //// 
.................... //// provide the following callbacks in their application to provide //// 
.................... //// encapsuated message support (SendEncapsulatedCommand and        //// 
.................... ////  GetEncapsulatedResponse):                                      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_SendEncapsulatedCommand(byte *ptr, unsigned int16 num)  //// 
.................... ////     PIC receives encapsulated command from host (PC), 'num'     //// 
.................... ////     bytes of message stored in 'ptr'.                           //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_GetEncapsulatedResponse(byte *ptr, unsigned int16 num)  //// 
.................... ////     Host (PC) is asking for 'num' bytes response from the PIC,  //// 
.................... ////     PIC should store up to 'num' bytes to 'ptr' as the          //// 
.................... ////     response.                                                   //// 
.................... ////                                                                 //// 
.................... //// Due to the design of the USB stack, all encapsulated messages   //// 
.................... //// must be smaller than one endpoint 0 packet.  They cannot be     //// 
.................... //// equal in size or larger than the endpoint 0 size.  See          //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH.                                      //// 
.................... ////                                                                 //// 
.................... ////                                                                 //// 
.................... //// BUFFER SIZES                                                    //// 
.................... //// -------------------------------------------------------------   //// 
.................... //// USB_CDC_DATA_IN_SIZE controls the PIC->PC buffer size.  The     //// 
.................... ////  total buffer size will be ((USB_CDC_DATA_IN_SIZE*2)-1).        //// 
.................... ////  Full speed devices limit this value to be 64.  To increase     //// 
.................... ////  the size of the local PIC buffer you can also define           //// 
.................... ////  USB_CDC_DATA_LOCAL_SIZE.  If USB_CDC_DATA_LOCAL_SIZE is        //// 
.................... ////  defined then the total PIC->PC buffer size would be            //// 
.................... ////  USB_CDC_DATA_LOCAL_SIZE+USB_CDC_DATA_IN_SIZE.                  //// 
.................... ////  If USB_CDC_DATA_IN_SIZE is not defined, the default value      //// 
.................... ////  of 64 is used.  If USB_CDC_DATA_LOCAL_SIZE is not defined      //// 
.................... ////  then this option isn't used.                                   //// 
.................... ////                                                                 //// 
.................... ////                                                                 //// 
.................... //// INTERRUPT LIMITATIONS                                           //// 
.................... //// -------------------------------------------------------------   //// 
.................... //// This section is only relevant if you are using USB interrupts   //// 
.................... ////  and not the USB_ISR_POLLING option.                            //// 
.................... ////                                                                 //// 
.................... //// USB handling is complex, often requiring several packet         //// 
.................... ////  transmissions to accomplish transfer of one block of data.     //// 
.................... ////  Most of this processing is done in the USB ISR.  Because       //// 
.................... ////  of this you cannot call usb_cdc_putc() inside another ISR, the //// 
.................... ////  USB ISR or when ISRs are disabled.  To workaround this problem,   //// 
.................... ////  use usb_cdc_putc_fast() and the USB_CDC_DELAYED_FLUSH option.  //// 
.................... ////  This isn't perfect, because if you use usb_cdc_putc_fast() to  //// 
.................... ////  overflow the TX buffer than data will be lost.                 //// 
.................... ////                                                                 //// 
.................... //// You also cannot call usb_cdc_getc() inside another ISR, the USB //// 
.................... ////  ISR, USB_CDC_ISR() or when interrupts are disabled UNLESS      //// 
.................... ////  usb_cdc_kbhit() returns TRUE.  It is for this reason           //// 
.................... ////  ex_usb_serial3.c uses a statemachine for reception of data.    //// 
.................... ////                                                                 //// 
.................... //// ex_usb_serial3.c shows an example of working around these       //// 
.................... ////  ISR limitations.  Failure to follow these limitations can      //// 
.................... ////  cause the PIC to lockup.  These limtations only need to be     //// 
.................... ////  followed in the conditions listed above (writing code in the   //// 
.................... ////  ISR or interrupts are disabled).                               //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// VERSION HISTORY                                                 //// 
.................... ////                                                                 //// 
.................... //// Nov 20th, 2014:                                                 //// 
.................... ////  While usb_cdc_putc() waits for local buffer to be free, also   //// 
.................... ////     check the endpoint buffer in case there was a situation     //// 
.................... ////     that the ISR for this event was missed.                     //// 
.................... ////                                                                 //// 
.................... //// Dec 16th, 2013:                                                 //// 
.................... ////  Added encapsulated message support.  See                       //// 
.................... ////     USB_CDC_USE_ENCAPSULATED above for documentation.           //// 
.................... ////                                                                 //// 
.................... //// May 31st, 2013:                                                 //// 
.................... ////  usb_cdc_putready() now returns the number of bytes available.  //// 
.................... ////                                                                 //// 
.................... //// May 23rd, 2013:                                                 //// 
.................... ////  Added usb_cdc_putd().                                          //// 
.................... ////                                                                 //// 
.................... //// February 18th, 2013:                                            //// 
.................... ////  Enhanced PIC16 support added.                                  //// 
.................... ////  Added USB_CDC_ISR(), USB_CDC_DELAYED_FLUSH and                 //// 
.................... ////     USB_CDC_DATA_LOCAL_SIZE.                                    //// 
.................... ////                                                                 //// 
.................... //// September 13th, 2012:                                           //// 
.................... ////  Fixed a possible corruption that would occur on 16bit PICs     //// 
.................... ////     (PIC24, dsPIC33).                                           //// 
.................... ////  Added usb_cdc_putempty().                                      //// 
.................... ////                                                                 //// 
.................... //// December 16th, 2011:                                            //// 
.................... ////  Added __USB_CDC_HELPERS_ONLY__.  If defined, this library will //// 
.................... ////     only include the get string helper functions.  This is      //// 
.................... ////     a rarely used option, used only if you already wrote your   //// 
.................... ////     own getc() and putc() routines.                             //// 
.................... ////  usb_cdc_flush_tx_buffer() checks len buffer before flushing .  //// 
.................... ////  usb_isr_tok_in_cdc_data_dne() doesn't check len, now that      //// 
.................... ////     usb_cdc_flush_tx_buffer() is checking len.                  //// 
.................... ////                                                                 //// 
.................... //// Oct 27th, 2011:                                                 //// 
.................... ////  Added SERIAL_STATE support.  See usb_cdc_serial_state() for    //// 
.................... ////     documentation.  In order for this to work,                  //// 
.................... ////     USB_CDC_COMM_IN_SIZE has to be 11 bytes or bigger.          //// 
.................... ////                                                                 //// 
.................... //// Oct 15th, 2010:                                                 //// 
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?  //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts     //// 
.................... ////     will not be used.  usb_task() must be called periodically   //// 
.................... ////     in your main loop.  If it is not called faster than once    //// 
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).   //// 
.................... ////                                                                 //// 
.................... //// Jan 28, 2010:                                                   //// 
.................... ////  Added usb_cdc_puts(str), which will fit the entire str into    //// 
.................... ////     one packet.                                                 //// 
.................... ////                                                                 //// 
.................... //// Jan 25, 2010:                                                   //// 
.................... ////  Ignore incoming 0 length packets.                              //// 
.................... ////                                                                 //// 
.................... //// June 9th, 2009:                                                 //// 
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.   //// 
.................... ////                                                                 //// 
.................... //// April 7th, 2009:                                                //// 
.................... ////   Vista 'code 10' issues resolved.                              //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... //// Nov 26th, 2007:                                                 //// 
.................... ////              usb_cdc_put_buffer_free() should be more stable.   //// 
.................... ////              Fixed a hang-up that would happen if you sent      //// 
.................... ////                 exactly 64 bytes.                               //// 
.................... ////                                                                 //// 
.................... //// Nov 6th, 2007:                                                  //// 
.................... ////              Compatabible with latest pic18_usb.h, which        //// 
.................... ////                 reduces RAM footprint of USB driver.            //// 
.................... ////              This driver now fits on 18F4450/2450 PICs.         //// 
.................... ////                                                                 //// 
.................... //// October 27th, 2005: Changed the way incoming packets are        //// 
.................... ////               handled in that CDC driver will not flush         //// 
.................... ////               endpoint until user has handled all data.  This   //// 
.................... ////               will prevent overflows as the USB will NAK        //// 
.................... ////               incoming packets until it is ready to receive     //// 
.................... ////               more.                                             //// 
.................... ////            When using 18F4550 family, the RX buffer is          //// 
.................... ////               mapped directly to the endpoint buffer - this     //// 
.................... ////               saves a chunk of RAM.                             //// 
.................... ////            When using the 18F4550 family, you can increase      //// 
.................... ////               the TX and RX size over 64 bytes.                 //// 
.................... ////            No longer send 0len packets in the TBE interrupt.    //// 
.................... ////            Hopefully fixed bugs that caused random crashes      //// 
.................... ////               if you tried sending more than 64 bytes.          //// 
.................... ////                                                                 //// 
.................... //// July 6th, 2005: Global interrupts disabled when writing to TX   //// 
.................... ////                   buffer.                                       //// 
.................... ////                                                                 //// 
.................... //// July 1st, 2005: Initial Release.                                //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... //input.c ported to use CDC: 
.................... float get_float_usb(); 
.................... signed long get_long_usb(); 
.................... signed int get_int_usb(); 
.................... void get_string_usb(char* s, unsigned int max); 
.................... BYTE gethex_usb(); 
.................... BYTE gethex1_usb(); 
....................  
.................... #if !defined(__USB_CDC_HELPERS_ONLY__) 
....................  
.................... //api for the user: 
.................... #define usb_cdc_kbhit() (usb_cdc_get_buffer_status.got) 
.................... #define usb_cdc_putempty() ((usb_cdc_put_buffer_nextin==0) && usb_cdc_put_buffer_free()) 
.................... #define usb_cdc_putready() (sizeof(usb_cdc_put_buffer)-usb_cdc_put_buffer_nextin) 
.................... #define usb_cdc_connected() (usb_cdc_got_set_line_coding) 
.................... void usb_cdc_putc_fast(char c); 
.................... char usb_cdc_getc(void); 
.................... void usb_cdc_putc(char c); 
.................... void usb_cdc_get_discard(void); 
....................  
.................... //functions automatically called by USB handler code 
.................... void usb_isr_tkn_cdc(void); 
.................... void usb_cdc_init(void); 
.................... void usb_isr_tok_out_cdc_control_dne(void); 
.................... void usb_isr_tok_in_cdc_data_dne(void); 
.................... void usb_isr_tok_out_cdc_data_dne(void); 
....................  
.................... void usb_cdc_flush_tx_buffer(void); 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // Include the CCS USB Libraries.  See the comments at the top of these 
.................... // files for more information 
.................... // 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... #ifndef __USB_PIC_PERIF__ 
.................... #define __USB_PIC_PERIF__   1 
.................... #endif 
....................  
.................... #if __USB_PIC_PERIF__ 
....................    #if defined(__PCM__) 
....................     #include <pic16f_usb.h>   //Microchip PIC16Fxxxx hardware layer for usb.c 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          pic16f_usb.h                           //// 
.................... ////                                                                 //// 
.................... //// Hardware layer for CCS's USB library.  This hardware layer      //// 
.................... //// supports the USB peripheral on the enhanced PIC family chips.   //// 
.................... //// Current supported families are:                                 //// 
.................... ////     PIC16F1454/1455/1459                                        //// 
.................... ////                                                                 //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      //// 
.................... //// for more documentation and a list of examples.                  //// 
.................... ////                                                                 //// 
.................... //// See the section labeled EXTRA USER FUNCTIONS for functions      //// 
.................... //// that are specific to only this HW peripheral that you may       //// 
.................... //// find useful to use in your application.                         //// 
.................... ////                                                                 //// 
.................... //// This driver lets you use endpoints 0 thru 15.  Endpoint 0 is    //// 
.................... //// the setup/control endpoint and is always anabled.               //// 
.................... //// You can use any endpoint, but to save RAM it is recommended     //// 
.................... //// that you use lower number endpoints and in order.  For example, //// 
.................... //// use endpoints 1, 2 and 3 INSTEAD OF using endpoints 1, 8        //// 
.................... //// and 15.                                                         //// 
.................... ////                                                                 //// 
.................... ////  USB_MAX_EP0_PACKET_LENGTH will be set to 8 regardless          //// 
.................... ////  of USB speed, to save RAM.                                     //// 
.................... ////                                                                 //// 
.................... ////   ************** NOTE ABOUT HW REQUIREMENTS ****************    //// 
.................... ////  If you are not using internal pullups, you will need to put    //// 
.................... ////  an internal pullup resistor on D+ or D+ depending on if you    //// 
.................... ////  want to use slow speed or full speed.  This code configures    //// 
.................... ////  the device to use internal pullups, see usb_init() if you      //// 
.................... ////  want to change that.                                           //// 
.................... ////                                                                 //// 
.................... ////  You need approximately 470nF cap on Vusb, even if you are      //// 
.................... ////  using the internal 3.3V USB regulator.                         //// 
.................... ////                                                                 //// 
.................... ////  To run at full speed, you must use the oscillator              //// 
.................... ////  configuration (PLLx) to set the PLL divide to 4MHz.  You can   //// 
.................... ////  configure the MCU clock to any speed (up to 48MHz) but the     //// 
.................... ////  PLL must run at 4Mhz to provide the USB peripheral with a      //// 
.................... ////  96MHz clock.  See the datasheet for details.                   //// 
.................... ////                                                                 //// 
.................... ////  To run at slow speed you must configure your MCU to run at     //// 
.................... ////  24Mhz.  See the datasheet for details.                         //// 
.................... ////                                                                 //// 
.................... ////   ****************  NOTE ABOUT INTERRUPTS  ******************   //// 
.................... //// This driver uses INT_USB.  It requires INT_USB to interrupt the //// 
.................... //// PIC when an event has happened on the USB Bus.  Therfore        //// 
.................... //// this code enables interrupts.  A user modification can be made  //// 
.................... //// to poll the USB interrupt flag instead of relying on an         //// 
.................... //// interrupt.                                                      //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History:                                                //// 
.................... ////                                                                 //// 
.................... //// Feb 15, 2013:                                                   //// 
.................... ////  Enhanced PIC16 support added.                                  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2013 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __PIC16F_USB_H__ 
.................... #DEFINE __PIC16F_USB_H__ 
....................  
.................... #DEFINE __USB_HARDWARE__ 
....................  
.................... //let the USB Stack know that we are using a PIC with internal USB peripheral 
.................... #DEFINE __PIC__   1 
....................  
.................... #ifndef USB_USE_FULL_SPEED 
....................  #define USB_USE_FULL_SPEED   1 
.................... #endif 
....................  
.................... #ifndef USB_MAX_EP0_PACKET_LENGTH 
.................... #define USB_MAX_EP0_PACKET_LENGTH   8 
.................... #endif 
....................  
.................... #if (!USB_USE_FULL_SPEED && (USB_MAX_EP0_PACKET_LENGTH!=8)) 
....................  #error Slow speed devices must use a max packet size of 8 for endpoint 0! 
.................... #endif 
....................  
.................... #if USB_MAX_EP0_PACKET_LENGTH < 8 
....................  #error Max Endpoint 0 length can't be less than 8! 
.................... #endif 
....................  
.................... #if USB_MAX_EP0_PACKET_LENGTH > 64 
....................  #error Max Endpoint 0 length can't be greater than 64! 
.................... #endif 
....................  
.................... #include <usb_hw_layer.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                         usb_hw_layer.h                            //// 
.................... ////                                                                   //// 
.................... //// HW Layer for the USB Stack.                                       //// 
.................... ////                                                                   //// 
.................... //// HW drivers for the USB stack must support this API.               //// 
.................... ////                                                                   //// 
.................... //// The HW driver must also have a token handler that will call       //// 
.................... //// usb_token_reset() when the device is init/reset, will call        //// 
.................... //// usb_isr_tok_setup_dne() when it receives a setup packet,          //// 
.................... //// will call usb_isr_tok_out_dne() when a new packet is received,    //// 
.................... //// and will call usb_isr_tok_in_dne() when a new packet is sent.     //// 
.................... //// See usb.h for documentation of these functions.                   //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __USB_HW_LAYER_H__ 
.................... #define __USB_HW_LAYER_H__ 
....................  
.................... enum USB_DTS_BIT {USB_DTS_DATA1=1, USB_DTS_TOGGLE=2, USB_DTS_DATA0=0, 
....................                    USB_DTS_STALL=3, USB_DTS_USERX=4}; 
....................  
....................  
.................... // USER LEVEL FUNCTIONS: 
....................  
.................... /***************************************************************************** 
.................... /* usb_init() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init(void); 
....................  
.................... /***************************************************************************** 
.................... /* usb_init_cs() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init_cs(void); 
....................  
.................... /***************************************************************************** 
.................... /* usb_task() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_task(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attach() 
.................... /* 
.................... /* Summary: Attach the D+/D- lines to the USB bus.  Enable the USB peripheral. 
.................... /* 
.................... /* You should wait until UCON_SE0 is clear before enabling reset/idle interrupt. 
.................... /*  
.................... /* Shouldn't be called by user, let usb_task() handle this. 
.................... /* 
.................... /* NOTE: If you are writing a new HW driver, this routine should call  
.................... /*       usb_token_reset() to reset the CH9 stack. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_attach(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_detach() 
.................... /* 
.................... /* Summary: Remove the D+/D- lines from the USB bus.  Basically, disable USB. 
.................... /* 
.................... /* Shouldn't be called by user, let usb_task() handle this. 
.................... /* 
.................... /* If the user does call this function while USB is connected, the USB  
.................... /* peripheral will be disabled only momentarily because usb_task() will 
.................... /* reconnect.  But this is a great way to cause the PC/HOST to cause a USB 
.................... /* reset of the device. 
.................... /* 
.................... /* NOTE: If you are writing a new HW driver, this routine should call  
.................... /*       usb_token_reset() to reset the CH9 stack. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_detach(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_put_packet() 
.................... /* 
.................... /* Input: endpoint - endpoint to send packet to (0..15). 
.................... /*        ptr - points to data to send. 
.................... /*        len - amount of data to send. 
.................... /*        toggle - whether to send data with a DATA0 pid, a DATA1 pid,  
.................... /*                 or toggle from the last DATAx pid. 
.................... /* 
.................... /* Output: TRUE if data was sent correctly, FALSE if it was not.  The only  
.................... /*         reason it will return FALSE is if because the TX buffer is still full  
.................... /*         from the last time it tried to send a packet. 
.................... /* 
.................... /* Summary: Sends one packet out the EP to the host.  Notice that there is a  
.................... /*          difference between a packet and a message.  If you wanted to send a  
.................... /*          512 byte message on an endpoint that only supported 64 byte packets, 
.................... /*          this would be accomplished this by sending 8 64-byte packets,  
.................... /*          followed by a 0 length packet.  If the last (or only packet) being  
.................... /*          sent is less than the max packet size defined in your descriptor  
.................... /*          then you do not need to send a 0 length packet to identify 
.................... /*          an end of message. 
.................... /* 
.................... /*          usb_puts() (provided in usb.c) will send a multi-packet message  
.................... /*          correctly and know if a 0 lenght packet needs to be sent. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_TX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_put_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl); 
....................  
.................... /******************************************************************************* 
.................... /* usb_get_packet(endpoint, *ptr, max) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: the amount of data taken from the buffer and saved to ptr. 
.................... /* 
.................... /*         NOTE - IF THERE IS NO PACKET TO GET YOU WILL GET INVALID RESULTS! 
.................... /*                VERIFY WITH USB_KBHIT() BEFORE YOU CALL USB_GET_PACKET()! 
.................... /* 
.................... /* Summary: Gets a packet of data from the USB endpoint buffer. 
.................... /*          Until this is called, if there is data in the receive buffer the 
.................... /*          PC/HOST will be prevented from sending more data.  Upon completion 
.................... /*          of this call, the endpoint will be freed and the PC/HOST will be 
.................... /*          allowed to send a new packet.  Only receives one packet, if you need  
.................... /*          to receive multiple packets or handle 0-length terminator packets, 
.................... /*          then use usb_gets(). 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_RX_SIZE 
.................... /* 
.................... /********************************************************************************/ 
.................... unsigned int16 usb_get_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max); 
....................  
.................... /**************************************************************************** 
.................... /* usb_kbhit(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check (0..15) 
.................... /* 
.................... /* Output: TRUE if there is new data in RX buffer, FALSE if there is not. 
.................... /* 
.................... /* Summary: Similar to kbhit(), sees if there is new data in the RX USB buffers. 
.................... /*          See API section of USB.H for more information. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_RX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_kbhit(unsigned int8 en); 
....................  
.................... /****************************************************************************** 
.................... /* usb_tbe(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: returns TRUE if this endpoint's IN buffer (PIC-PC) is empty and ready 
.................... /*         returns FALSE if this endpoint's IN buffer is still processing the last 
.................... /*         transmit or if this endpoint is invalid. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_TX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_tbe(unsigned int8 en); 
....................  
.................... //////////////// END USER LEVEL FUNCTIONS ///////////////////////////////////// 
....................  
....................  
.................... /// 
.................... /// BEGIN STACK LEVEL FUNCTIONS: These functions are meant to be called by 
.................... ///            the USB stack, and are not meant to be called by the  
.................... ///            user/application. 
.................... /// 
....................  
.................... /***************************************************************************** 
.................... /* usb_stall_ep() 
.................... /* 
.................... /* Input: endpoint - endpoint to stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Stalls specified endpoint.  If endpoint is stalled it will 
.................... /*          send STALL packet if the host tries to access this endpoint's  
.................... /*          buffer. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_stall_ep(unsigned int8 endpoint); 
....................  
....................  
.................... /***************************************************************************** 
.................... /* usb_unstall_ep(endpoint, direction) 
.................... /* 
.................... /* Input: endpoint - endpoint to un-stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Un-stalls endpoint. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_unstall_ep(unsigned int8 endpoint); 
....................  
.................... /***************************************************************************** 
.................... /* usb_endpoint_stalled() 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: returns a TRUE if endpoint is stalled, FALSE if it is not. 
.................... /* 
.................... /* Summary: Looks to see if an endpoint is stalled, or not.  Does not look to 
.................... /*          see if endpoint has been issued a STALL, just whether or not it is 
.................... /*          configured to STALL on the next packet.  See Set_Feature and  
.................... /*          Clear_Feature Chapter 9 requests. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_endpoint_stalled(unsigned int8 endpoint); 
....................  
.................... /***************************************************************************** 
.................... /* usb_set_address(address) 
.................... /* 
.................... /* Input: address - address the host specified that we use 
.................... /* 
.................... /* Summary: Configures the USB Peripheral for the specified device address.   
.................... /*          The host will now talk to use with the following address. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_set_address(unsigned int8 address); 
....................  
.................... /****************************************************************************** 
.................... /* usb_set_configured() 
.................... /* 
.................... /* Input: config - Configuration to use.  0 to uncofigure device. 
.................... /* 
.................... /* Summary: Configures or unconfigures device.  If configuring device it will 
.................... /*          enable all the endpoints the user specified for this configuration. 
.................... /*          If un-configuring device it will disable all endpoints. 
.................... /* 
.................... /*          NOTE: CCS only provides code to handle 1 configuration. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_set_configured(unsigned int8 config); 
....................  
.................... /****************************************************************************** 
.................... /* usb_disable_endpoints() 
.................... /* 
.................... /* Summary: Disables endpoints (all endpoints but 0) 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_disable_endpoints(void); 
....................  
....................  
.................... /******************************************************************************* 
.................... /* usb_disable_endpoint() 
.................... /* 
.................... /* Input: Endpoint to disable (0..15) 
.................... /* 
.................... /* Summary: Disables specified endpoint 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_disable_endpoint(unsigned int8 en); 
....................  
.................... /************************************************************** 
.................... /* usb_request_send_response(len) 
.................... /* usb_request_get_data() 
.................... /* usb_request_stall() 
.................... /* 
.................... /* Input: len - size of packet to send 
.................... /* 
.................... /* Summary: One of these 3 functions will be called by the USB stack after 
.................... /*          handling a SETUP packet. 
.................... /*           
.................... /*          After we process a SETUP request, we have 1 of three responses: 
.................... /*            1.) send a response IN packet 
.................... /*            2.) wait for followup OUT packet(s) with data 
.................... /*            3.) stall because we don't support that SETUP request 
.................... /* 
.................... /*          If we are sending data, the array usb_ep0_tx_buffer[] will hold 
.................... /*          the response and the USB Request handler code will call 
.................... /*          usb_request_send_response() to let us know how big the packet is. 
.................... /* 
.................... /*          If we are waiting for more data, usb_request_get_data() will 
.................... /*          be called by the USB request handler code to configure the EP0 OUT 
.................... /*          endpoint to be ready for more data 
.................... /* 
.................... /*          If we don't support a request, usb_request_stall() will be called 
.................... /*          by the USB request handler code to stall the endpoint 0. 
.................... /* 
.................... /*          The operation of these functions depends on how SETUP packets 
.................... /*          are handled in the hardware layer. 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_request_send_response(unsigned int8 len); 
.................... void usb_request_get_data(void); 
.................... void usb_request_stall(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... //////////////////////// EXTRA USER FUNCTIONS ///////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_flush_in() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark for transfer 
.................... /*        len - length of data that is being tramsferred 
.................... /*        tgl - Data toggle synchronization for this packet 
.................... /* 
.................... /* Output: TRUE if success, FALSE if error (we don't control the endpoint) 
.................... /* 
.................... /* Summary: Marks the endpoint ready for transmission.  You must 
.................... /*          have already loaded the endpoint buffer with data. 
.................... /*          (IN is PIC -> PC). 
.................... /*          This routine is useful if you want to setup an endpoint by 
.................... /*          writing to the buffer directly. 
.................... /*          This routine is not necessary if you use usb_put_packet(). 
.................... /***************************************************************/ 
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl); 
....................  
.................... /************************************************************** 
.................... /* usb_flush_out() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark for release 
.................... /*        tgl - Data toggle synchronization to expect in the next packet 
.................... /* 
.................... /* Output: NONE 
.................... /* 
.................... /* Summary: Clears the previously received packet, and then marks this 
.................... /*          endpoint's receive buffer as ready for more data. 
.................... /*          (OUT is PC -> PIC).  This routine is useful if you do not 
.................... /*          want to use usb_get_packet(), instead you want to handle with 
.................... /*          the endpoint buffer directly.  Also see usb_rx_packet_size(). 
.................... /*          This routine is not necessary if you use usb_get_packet(). 
.................... /***************************************************************/ 
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl); 
....................  
.................... /************************************************************** 
.................... /* usb_rx_packet_size() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark to check 
.................... /* 
.................... /* Output: Returns the number of bytes in the endpoint's receive buffer. 
.................... /* 
.................... /* Summary: Read the number of data stored in the receive buffer.  When you 
.................... /*    have handled the data, use usb_flush_out() to clear the buffer.  The 
.................... /*    result may be invalid if usb_kbhit() returns false for this endpoint. 
.................... /*    This routine is not necessary if you use usb_get_packet(). 
.................... /***************************************************************/ 
.................... int16 usb_rx_packet_size(int8 endpoint); 
....................  
.................... #ENDIF 
....................  
....................    #elif defined(__PCH__) 
....................     #include <pic18_usb.h>   //Microchip 18Fxx5x hardware layer for usb.c 
....................    #else 
....................     #include <pic24_usb.h>   //Microchip 18Fxx5x hardware layer for usb.c 
....................    #endif 
.................... #else 
....................    #include <usbn960x.h> 
.................... #endif 
.................... #ifndef __USB_DESCRIPTORS__ 
.................... #include <usb_desc_cdc.h>   //USB Configuration and Device descriptors for this USB device 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                         usb_desc_cdc.h                            //// 
.................... ////                                                                   //// 
.................... //// An example set of device / configuration descriptors for use with //// 
.................... //// CCS's CDC Virtual COM Port driver (see usb_cdc.h)                 //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        //// 
.................... //// for more documentation and a list of examples.                    //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// Oct 27th, 2011:                                                   //// 
.................... ////   Increased USB_CDC_COMM_IN_SIZE default size to 11 so we can     //// 
.................... ////     send SERIAL_STATE messages in one packet.                     //// 
.................... ////                                                                   //// 
.................... //// April 7th, 2009:                                                  //// 
.................... ////   Vista 'code 10' issues resolved.                                //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// 10/28/05:                                                         //// 
.................... ////    Bulk endpoint sizes updated to allow more than 255 byte        //// 
.................... ////    packets.                                                       //// 
.................... ////    Changed device to USB 1.10                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_DESCRIPTORS__ 
.................... #DEFINE __USB_DESCRIPTORS__ 
....................  
.................... ///////// config options, although it's best to leave alone for this demo ///// 
.................... #ifndef  USB_CONFIG_PID 
....................    #define  USB_CONFIG_PID       0x000b 
.................... #endif 
.................... #ifndef  USB_CONFIG_VID 
....................    #define  USB_CONFIG_VID       0x2405 
.................... #endif 
.................... #ifndef  USB_CONFIG_BUS_POWER 
....................    #define  USB_CONFIG_BUS_POWER 100   //100mA  (range is 0..500) 
.................... #endif 
.................... #ifndef  USB_CONFIG_VERSION 
....................    #define  USB_CONFIG_VERSION   0x0100      //01.00  //range is 00.00 to 99.99 
.................... #endif 
.................... //////// end config /////////////////////////////////////////////////////////// 
....................  
.................... #DEFINE USB_HID_DEVICE  FALSE 
.................... #DEFINE USB_CDC_DEVICE  TRUE 
....................  
.................... #define USB_CDC_COMM_IN_ENDPOINT       1 
.................... #ifndef USB_CDC_COMM_IN_SIZE 
.................... #define USB_CDC_COMM_IN_SIZE           11 
.................... #endif 
.................... #define USB_EP1_TX_ENABLE  USB_ENABLE_INTERRUPT 
.................... #define USB_EP1_TX_SIZE  USB_CDC_COMM_IN_SIZE 
....................  
.................... //pic to pc endpoint config 
.................... #define USB_CDC_DATA_IN_ENDPOINT       2 
.................... #ifndef USB_CDC_DATA_IN_SIZE 
.................... #define USB_CDC_DATA_IN_SIZE           64 
.................... #endif 
.................... #define USB_EP2_TX_ENABLE  USB_ENABLE_BULK 
.................... #define USB_EP2_TX_SIZE  USB_CDC_DATA_IN_SIZE 
....................  
.................... //pc to pic endpoint config 
.................... #define USB_CDC_DATA_OUT_ENDPOINT       2 
.................... #ifndef USB_CDC_DATA_OUT_SIZE 
.................... #define USB_CDC_DATA_OUT_SIZE           64 
.................... #endif 
.................... #define USB_EP2_RX_ENABLE  USB_ENABLE_BULK 
.................... #define USB_EP2_RX_SIZE  USB_CDC_DATA_OUT_SIZE 
....................  
.................... #include <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense macro               //// 
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      ////  
.................... ////        assumes that USB is always connected.                      //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... ////  Feb 18th, 2013                                                   //// 
.................... ////     Added some extra checks to make sure packet size are legal    //// 
.................... ////        for USB speed.                                             //// 
.................... ////                                                                   //// 
.................... ////  April 2nd, 2012                                                  //// 
.................... ////     Initial version of CDC+HID composite device support           //// 
.................... ////                                                                   //// 
.................... //// Oct 15th, 2010:                                                   //// 
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    //// 
.................... ////  Added initial 18F47J53 family support.                           //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       //// 
.................... ////     will not be used.  usb_task() must be called periodically     //// 
.................... ////     in your main loop.  If it is not called faster than once      //// 
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     //// 
.................... ////                                                                   //// 
.................... //// September 24th, 2010:                                             //// 
.................... ////  Many descriptor files had the self powered bit set incorrectly   //// 
.................... ////     based on USB_CONFIG_BUS_POWER.                                //// 
.................... ////                                                                   //// 
.................... //// September 9th, 2010:                                              //// 
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards //// 
.................... ////     in HID report descriptor of usb_desc_hid.h                    //// 
.................... ////                                                                   //// 
.................... //// September 2nd, 2010:                                              //// 
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    //// 
.................... ////     (dsPIC, PIC24) resolved.                                      //// 
.................... ////                                                                   //// 
.................... //// August 31st, 2010:                                                //// 
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             //// 
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                //// 
.................... ////                                                                   //// 
.................... //// April 28th, 2010:                                                 //// 
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          //// 
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       //// 
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          //// 
.................... ////     compatibility).                                               //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #if defined(USB_CON_SENSE_PIN) 
....................  #undef USB_CABLE_IS_ATTACHED 
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN) 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if defined(USB_CABLE_IS_ATTACHED) 
....................  #define usb_attached() USB_CABLE_IS_ATTACHED() 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
.................... #define USB_DESC_IAD_TYPE        0x0b 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
.................... #define USB_DESC_IAD_LEN         8 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... const unsigned int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const unsigned int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start config descriptor 
.................... ///   right now we only support one configuration descriptor. 
.................... ///   the config, interface, class, and endpoint goes into this array. 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    #DEFINE USB_TOTAL_CONFIG_LEN      67  //config+interface+class+endpoint+endpoint (2 endpoints) 
....................  
....................    const char USB_CONFIG_DESC[] = { 
....................    //IN ORDER TO COMPLY WITH WINDOWS HOSTS, THE ORDER OF THIS ARRAY MUST BE: 
....................       //    config(s) 
....................       //    interface(s) 
....................       //    class(es) 
....................       //    endpoint(s) 
....................  
....................    //config_descriptor for config index 1 
....................          USB_DESC_CONFIG_LEN, //length of descriptor size          ==0 
....................          USB_DESC_CONFIG_TYPE, //constant CONFIGURATION (CONFIGURATION 0x02)     ==1 
....................          USB_TOTAL_CONFIG_LEN,0, //size of all data returned for this config      ==2,3 
....................          2, //number of interfaces this device supports       ==4 
....................          0x01, //identifier for this configuration.  (IF we had more than one configurations)      ==5 
....................          0x00, //index of string descriptor for this configuration      ==6 
....................         #if USB_CONFIG_BUS_POWER 
....................          0x80, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7 
....................         #else 
....................          0xC0, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7 
....................         #endif 
....................          USB_CONFIG_BUS_POWER/2, //maximum bus power required (maximum milliamperes/2)  (0x32 = 100mA)   ==8 
....................  
....................  
....................    //interface descriptor 0 (comm class interface) 
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =9 
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =10 
....................          0x00, //number defining this interface (IF we had more than one interface)    ==11 
....................          0x00, //alternate setting     ==12 
....................          1, //number of endpoints   ==13 
....................          0x02, //class code, 02 = Comm Interface Class     ==14 
....................          0x02, //subclass code, 2 = Abstract     ==15 
....................          0x01, //protocol code, 1 = v.25ter      ==16 
....................          0x00, //index of string descriptor for interface      ==17 
....................  
....................    //class descriptor [functional header] 
....................          5, //length of descriptor    ==18 
....................          0x24, //dscriptor type (0x24 == )      ==19 
....................          0, //sub type (0=functional header) ==20 
....................          0x10,0x01, //      ==21,22 //cdc version 
....................  
....................    //class descriptor [acm header] 
....................          4, //length of descriptor    ==23 
....................          0x24, //dscriptor type (0x24 == )      ==24 
....................          2, //sub type (2=ACM)   ==25 
....................          2, //capabilities    ==26  //we support Set_Line_Coding, Set_Control_Line_State, Get_Line_Coding, and the notification Serial_State. 
....................  
....................    //class descriptor [union header] 
....................          5, //length of descriptor    ==27 
....................          0x24, //dscriptor type (0x24 == )      ==28 
....................          6, //sub type (6=union)    ==29 
....................          0, //master intf     ==30  //The interface number of the Communication or Dat a Cl ass interface, designated as the masteror controlling interface for the union. 
....................          1, //save intf0      ==31  //Interface number of first slave or associated interface in the union. * 
....................  
....................    //class descriptor [call mgmt header] 
....................          5, //length of descriptor    ==32 
....................          0x24, //dscriptor type (0x24 == )      ==33 
....................          1, //sub type (1=call mgmt)   ==34 
....................          0, //capabilities          ==35  //device does not handle call management itself 
....................          1, //data interface        ==36  //interface number of data class interface 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==37 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==38 
....................          USB_CDC_COMM_IN_ENDPOINT | 0x80, //endpoint number and direction 
....................          0x03, //transfer type supported (0x03 is interrupt)         ==40 
....................          USB_CDC_COMM_IN_SIZE,0x00, //maximum packet size supported                  ==41,42 
....................          250,  //polling interval, in ms.  (interrupt endpoint cant be smaller than 10 for slow speed devices)      ==43 
....................  
....................    //interface descriptor 1 (data class interface) 
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =44 
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =45 
....................          0x01, //number defining this interface (IF we had more than one interface)    ==46 
....................          0x00, //alternate setting     ==47 
....................          2, //number of endpoints   ==48 
....................          0x0A, //class code, 0A = Data Interface Class     ==49 
....................          0x00, //subclass code      ==50 
....................          0x00, //protocol code      ==51 
....................          0x00, //index of string descriptor for interface      ==52 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==53 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==54 
....................          USB_CDC_DATA_OUT_ENDPOINT, //endpoint number and direction (0x02 = EP2 OUT)       ==55 
....................          0x02, //transfer type supported (0x02 is bulk)         ==56 
....................          USB_CDC_DATA_OUT_SIZE & 0xFF, (USB_CDC_DATA_OUT_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==57, 58 
....................          1,  //polling interval, in ms.   ==59 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==60 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==61 
....................          USB_CDC_DATA_IN_ENDPOINT | 0x80, //endpoint number and direction (0x82 = EP2 IN)       ==62 
....................          0x02, //transfer type supported (0x02 is bulk)         ==63 
....................          USB_CDC_DATA_IN_SIZE & 0xFF, (USB_CDC_DATA_IN_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==66, 67 
....................          1  //polling interval, in ms.   ==68 
....................    }; 
....................  
....................    //****** BEGIN CONFIG DESCRIPTOR LOOKUP TABLES ******** 
....................    //since we can't make pointers to constants in certain pic16s, this is an offset table to find 
....................    //  a specific descriptor in the above table. 
....................  
....................    //the maximum number of interfaces seen on any config 
....................    //for example, if config 1 has 1 interface and config 2 has 2 interfaces you must define this as 2 
....................    #define USB_MAX_NUM_INTERFACES   2 
....................  
....................    //define how many interfaces there are per config.  [0] is the first config, etc. 
....................    const char USB_NUM_INTERFACES[USB_NUM_CONFIGURATIONS]={2}; 
....................  
....................    //define where to find class descriptors 
....................    //first dimension is the config number 
....................    //second dimension specifies which interface 
....................    //last dimension specifies which class in this interface to get, but most will only have 1 class per interface 
....................    //if a class descriptor is not valid, set the value to 0xFFFF 
....................    const int8 USB_CLASS_DESCRIPTORS[USB_NUM_CONFIGURATIONS][USB_MAX_NUM_INTERFACES][4]= 
....................    { 
....................    //config 1 
....................       //interface 0 
....................          //class 1-4 
....................          18,23,27,32, 
....................       //interface 1 
....................          //no classes for this interface 
....................          0xFF,0xFF,0xFF,0xFF 
....................    }; 
....................  
....................    #if (sizeof(USB_CONFIG_DESC) != USB_TOTAL_CONFIG_LEN) 
....................       #error USB_TOTAL_CONFIG_LEN not defined correctly 
....................    #endif 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start device descriptors 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    const char USB_DEVICE_DESC[USB_DESC_DEVICE_LEN] ={ 
....................       //starts of with device configuration. only one possible 
....................          USB_DESC_DEVICE_LEN, //the length of this report   ==0 
....................          0x01, //the constant DEVICE (DEVICE 0x01)  ==1 
....................          0x10,0x01, //usb version in bcd  ==2,3 
....................          0x02, //class code. 0x02=Communication Device Class ==4 
....................          0x00, //subclass code ==5 
....................          0x00, //protocol code ==6 
....................          USB_MAX_EP0_PACKET_LENGTH, //max packet size for endpoint 0. (SLOW SPEED SPECIFIES 8) ==7 
....................          USB_CONFIG_VID & 0xFF, ((USB_CONFIG_VID >> 8) & 0xFF), //vendor id       ==9, 10 
....................          USB_CONFIG_PID & 0xFF, ((USB_CONFIG_PID >> 8) & 0xFF), //product id, don't use 0xffff       ==11, 12 
....................          USB_CONFIG_VERSION & 0xFF, ((USB_CONFIG_VERSION >> 8) & 0xFF), //device release number  ==13,14 
....................          0x01, //index of string description of manufacturer. therefore we point to string_1 array (see below)  ==14 
....................          0x02, //index of string descriptor of the product  ==15 
....................          0x00, //index of string descriptor of serial number  ==16 
....................          USB_NUM_CONFIGURATIONS  //number of possible configurations  ==17 
....................    }; 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start string descriptors 
.................... ///   String 0 is a special language string, and must be defined.  People in U.S.A. can leave this alone. 
.................... /// 
.................... ///   You must define the length else get_next_string_character() will not see the string 
.................... ///   Current code only supports 10 strings (0 thru 9) 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
.................... #if !defined(USB_STRINGS_OVERWRITTEN) 
.................... // Here is where the "CCS" Manufacturer string and "SERIAL DEMO" are stored. 
.................... // Strings are saved as unicode. 
.................... // These strings are mostly only displayed during the add hardware wizard. 
.................... // Once the operating system drivers have been installed it will usually display 
.................... // the name from the drivers .INF. 
.................... char const USB_STRING_DESC[]={ 
....................    //string 0 
....................          4, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          0x09,0x04,   //Microsoft Defined for US-English 
....................    //string 1  - manufacturer 
....................          8, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'C',0, 
....................          'C',0, 
....................          'S',0, 
....................    //string 2 - product 
....................          32, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'C',0, 
....................          'C',0, 
....................          'S',0, 
....................          ' ',0, 
....................          'U',0, 
....................          'S',0, 
....................          'B',0, 
....................          ' ',0, 
....................          't',0, 
....................          'o',0, 
....................          ' ',0, 
....................          'U',0, 
....................          'A',0, 
....................          'R',0, 
....................          'T',0 
.................... }; 
.................... #endif   //!defined(USB_STRINGS_OVERWRITTEN) 
....................  
.................... #ENDIF 
....................  
.................... #endif 
....................  
.................... struct { 
....................    int1 got; 
....................   #if USB_CDC_DATA_OUT_SIZE>=0x100 
....................    unsigned int16 len; 
....................    unsigned int16 index; 
....................   #else 
....................    unsigned int8 len; 
....................    unsigned int8 index; 
....................   #endif 
.................... } usb_cdc_get_buffer_status; 
....................  
.................... #include <usb.c>        //handles usb setup tokens and get descriptor reports 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             usb.c                                 //// 
.................... ////                                                                   //// 
.................... //// Standard USB request and token handler code.                      //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        //// 
.................... //// for more documentation and a list of examples.                    //// 
.................... ////                                                                   //// 
.................... //// The majority of this code is called and used by the interrupt     //// 
.................... //// generated by the hardware level, and therefore it is not meant    //// 
.................... //// to be called by the user.  The functions that are meant to be     //// 
.................... //// called by the user (init, put packet, get packet, etc) are        //// 
.................... //// documented in USB.H.                                              //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////    This code will not create a multiple configuration device.     //// 
.................... ////    If you wish to create a multiple configuration device then you //// 
.................... ////    will have to modify these drivers.                             //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////   This code does not support Get_Idle or Set_Idle HID-specific    //// 
.................... ////   requests.  These requests are optional.  If you want to support //// 
.................... ////   these requests you must provide the code yourself.  See         //// 
.................... ////   usb_isr_tkn_setup_ClassInterface() if you wish to add this      //// 
.................... ////   support.                                                        //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// If you wish to provide your own USB peripheral hardware layer, it //// 
.................... //// must must provide the API as described in usb_hw_layer.h.         //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// March 20, 2015                                                    //// 
.................... ////     USB_STRING_DESC_OFFSET no longer used.                        //// 
.................... ////                                                                   //// 
.................... //// Feb 6th, 2015                                                     //// 
.................... ////     Fixed 'len' not being intiailized in usb_gets()               //// 
.................... ////                                                                   //// 
.................... ////  Feb 18th, 2013                                                   //// 
.................... ////     Added some extra checks to make sure packet size are legal    //// 
.................... ////        for USB speed.                                             //// 
.................... ////                                                                   //// 
.................... ////  April 2nd, 2012                                                  //// 
.................... ////     Initial version of CDC+HID composite device support           //// 
.................... ////                                                                   //// 
.................... //// June 8th, 2011:                                                   //// 
.................... ////  Problem with usb_gets() and usb_puts() and specifying timeout=0  //// 
.................... ////     (for no timeout) resolved.                                    //// 
.................... ////                                                                   //// 
.................... //// September 2nd, 2010:                                              //// 
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    //// 
.................... ////     (dsPIC, PIC24) resolved.                                      //// 
.................... ////                                                                   //// 
.................... //// April 28th, 2010:                                                 //// 
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          //// 
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       //// 
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          //// 
.................... ////     compatibility).                                               //// 
.................... ////                                                                   //// 
.................... //// November 13th, 2009:                                              //// 
.................... ////  usb_endpoint_is_valid() has an extra check.                      //// 
.................... ////                                                                   //// 
.................... //// June 9th, 2009:                                                   //// 
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.     //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// Dec 14, 2007:                                                     //// 
.................... ////  usb_kbhit() moved to device driver.                              //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_puts() packet_size and this_packet_len changed to 16bits.    //// 
.................... ////  usb_gets() len, packet_size and this_packet_len to 16bits.       //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release.                                         //// 
.................... ////  usb_kbhit() removed, usb_kbhit() now implemented in hardware     //// 
.................... ////    layer.                                                         //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////  TODO: alot of indexing and length handling for descriptors is    //// 
.................... ////   only 8bit, so make sure all descriptor tables are less than     //// 
.................... ////   256 bytes long.                                                 //// 
.................... ////                                                                   //// 
.................... //// Apr 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_puts() doesn't need max packet size as a paremeter, uses     //// 
.................... ////   usb_ep_tx_size[] defined in usb.h                               //// 
.................... ////  usb_puts() timeout parameter now in ms, not seconds.             //// 
.................... ////  USB Stack no longer buffers incoming data.  If there is data to  //// 
.................... ////   get usb_kbhit(en) will return TRUE and the data will sit in     //// 
.................... ////   the endpoint buffer until you usb_get_packet(), which will      //// 
.................... ////   then free the endpoint buffer for more data.  This affects      //// 
.................... ////   routines such as usb_gets() and usb_kbhit().                    //// 
.................... ////  usb_gets() no longer reads buffered data (see above note),       //// 
.................... ////   now it reads multiple packets in the same way usb_puts()        //// 
.................... ////   writes multiple packets                                         //// 
.................... ////  usb_kbhit() is hardware specific, so has been moved to hardware  //// 
.................... ////   layer.                                                          //// 
.................... ////                                                                   //// 
.................... //// Nov 11th, 2004:                                                   //// 
.................... ////  No longer includes wrong descriptor header.                      //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// December 5th, 2003: Fixed a potential bug where descriptors are   //// 
.................... ////         evenly dividable by 8 (MAX_EP0_PACKET_SIZE)               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Problem with usb_puts and timeout fixed.      //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Typo fixed in get_next_string_character(),    //// 
.................... ////                     although it didn't cause any serious problems //// 
.................... ////                                                                   //// 
.................... //// October 25th, 2002: Another change to usb_puts() was made to fix  //// 
.................... ////                     problems with multiple packet messages        //// 
.................... //// October 29th, 2002: Fixed a problem with multiple packet string   //// 
.................... ////                     descriptors that require a 0 len packet to    //// 
.................... ////                     end message.                                  //// 
.................... ////                                                                   //// 
.................... //// October 23rd, 2002: usb_puts() will bomb out of error quicker     //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_DRIVER__ 
.................... #DEFINE __USB_DRIVER__ 
....................  
.................... #ifndef debug_usb_control 
....................    #define debug_usb_control(a,b,c,d,e,f,g,h,i,j,k,l,m,n) 
.................... #endif 
....................  
.................... #ifndef debug_usb_token 
....................    #define debug_usb_token(a,b,c,d,e,f,g,h,i,j,k,l,m,n) 
.................... #endif 
....................  
.................... #ifndef debug_usb_packet 
....................    #define debug_usb_packet(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) 
....................    #define debug_display_ram(len, ptr) 
.................... #else 
....................    void debug_display_ram(unsigned int8 len, unsigned int8 *ptr)  
....................    { 
....................       while(len--) 
....................       { 
....................          debug_usb_packet(debug_putc, "%02X", *ptr++); 
....................       } 
....................    } 
.................... #endif 
....................  
.................... // legacy 
.................... #ifndef debug_usb 
....................    #define debug_usb(a,b,c,d,e,f,g,h,i,j,k,l) 
.................... #endif 
....................  
.................... #include <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense macro               //// 
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      ////  
.................... ////        assumes that USB is always connected.                      //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... ////  Feb 18th, 2013                                                   //// 
.................... ////     Added some extra checks to make sure packet size are legal    //// 
.................... ////        for USB speed.                                             //// 
.................... ////                                                                   //// 
.................... ////  April 2nd, 2012                                                  //// 
.................... ////     Initial version of CDC+HID composite device support           //// 
.................... ////                                                                   //// 
.................... //// Oct 15th, 2010:                                                   //// 
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    //// 
.................... ////  Added initial 18F47J53 family support.                           //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       //// 
.................... ////     will not be used.  usb_task() must be called periodically     //// 
.................... ////     in your main loop.  If it is not called faster than once      //// 
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     //// 
.................... ////                                                                   //// 
.................... //// September 24th, 2010:                                             //// 
.................... ////  Many descriptor files had the self powered bit set incorrectly   //// 
.................... ////     based on USB_CONFIG_BUS_POWER.                                //// 
.................... ////                                                                   //// 
.................... //// September 9th, 2010:                                              //// 
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards //// 
.................... ////     in HID report descriptor of usb_desc_hid.h                    //// 
.................... ////                                                                   //// 
.................... //// September 2nd, 2010:                                              //// 
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    //// 
.................... ////     (dsPIC, PIC24) resolved.                                      //// 
.................... ////                                                                   //// 
.................... //// August 31st, 2010:                                                //// 
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             //// 
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                //// 
.................... ////                                                                   //// 
.................... //// April 28th, 2010:                                                 //// 
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          //// 
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       //// 
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          //// 
.................... ////     compatibility).                                               //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #if defined(USB_CON_SENSE_PIN) 
....................  #undef USB_CABLE_IS_ATTACHED 
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN) 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if defined(USB_CABLE_IS_ATTACHED) 
....................  #define usb_attached() USB_CABLE_IS_ATTACHED() 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
.................... #define USB_DESC_IAD_TYPE        0x0b 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
.................... #define USB_DESC_IAD_LEN         8 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... const unsigned int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const unsigned int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... #if defined(__PIC16F_USB_H__) 
....................  #include <pic16f_usb.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          pic16_usb.c                            //// 
.................... ////                                                                 //// 
.................... //// Hardware layer for CCS's USB library.  See pic16_usb.h more     //// 
.................... //// documentation about the PIC18 hardware layer.                   //// 
.................... ////                                                                 //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      //// 
.................... //// for more documentation and a list of examples.                  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History:                                                //// 
.................... ////                                                                 //// 
.................... //// Feb 15, 2013:                                                   //// 
.................... ////  Enhanced PIC16 support added.                                  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2013 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __PIC16F_USB_C__ 
.................... #DEFINE __PIC16F_USB_C__ 
....................  
.................... #INCLUDE <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense macro               //// 
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      ////  
.................... ////        assumes that USB is always connected.                      //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... ////  Feb 18th, 2013                                                   //// 
.................... ////     Added some extra checks to make sure packet size are legal    //// 
.................... ////        for USB speed.                                             //// 
.................... ////                                                                   //// 
.................... ////  April 2nd, 2012                                                  //// 
.................... ////     Initial version of CDC+HID composite device support           //// 
.................... ////                                                                   //// 
.................... //// Oct 15th, 2010:                                                   //// 
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    //// 
.................... ////  Added initial 18F47J53 family support.                           //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       //// 
.................... ////     will not be used.  usb_task() must be called periodically     //// 
.................... ////     in your main loop.  If it is not called faster than once      //// 
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     //// 
.................... ////                                                                   //// 
.................... //// September 24th, 2010:                                             //// 
.................... ////  Many descriptor files had the self powered bit set incorrectly   //// 
.................... ////     based on USB_CONFIG_BUS_POWER.                                //// 
.................... ////                                                                   //// 
.................... //// September 9th, 2010:                                              //// 
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards //// 
.................... ////     in HID report descriptor of usb_desc_hid.h                    //// 
.................... ////                                                                   //// 
.................... //// September 2nd, 2010:                                              //// 
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    //// 
.................... ////     (dsPIC, PIC24) resolved.                                      //// 
.................... ////                                                                   //// 
.................... //// August 31st, 2010:                                                //// 
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             //// 
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                //// 
.................... ////                                                                   //// 
.................... //// April 28th, 2010:                                                 //// 
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          //// 
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       //// 
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          //// 
.................... ////     compatibility).                                               //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #if defined(USB_CON_SENSE_PIN) 
....................  #undef USB_CABLE_IS_ATTACHED 
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN) 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if defined(USB_CABLE_IS_ATTACHED) 
....................  #define usb_attached() USB_CABLE_IS_ATTACHED() 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
.................... #define USB_DESC_IAD_TYPE        0x0b 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
.................... #define USB_DESC_IAD_LEN         8 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... const unsigned int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const unsigned int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... #bit USBIE=getenv("BIT:USBIE") 
....................  
.................... //if you are worried that the PIC is not receiving packets because a bug in the 
.................... //DATA0/DATA1 synch code, you can set this to TRUE to ignore the DTS on 
.................... //receiving. 
.................... #ifndef USB_IGNORE_RX_DTS 
....................  #define USB_IGNORE_RX_DTS FALSE 
.................... #endif 
....................  
.................... #ifndef USB_IGNORE_TX_DTS 
....................  #define USB_IGNORE_TX_DTS FALSE 
.................... #endif 
....................  
.................... // define only USB_RAM_START (USB_RAM_START_LINEAR and USB_RAM_START_TRADITIONAL) if BDT and Endpoint buffers must share a specific block of RAM, 
.................... // otherwise define only USB_BDT_START (USB_BDT_START_LINEAR and USB_BDT_START_TRADITIONAL) if BDT needs to be in a special place but endpoint buffers can be anywere, 
.................... #if ((getenv("DEVICE")=="PIC16F1454") ||  \ 
....................      (getenv("DEVICE")=="PIC16F1455") ||  \ 
....................      (getenv("DEVICE")=="PIC16F1459") ||  \ 
....................      (getenv("DEVICE")=="PIC16LF1454") ||  \ 
....................      (getenv("DEVICE")=="PIC16LF1455") ||  \ 
....................      (getenv("DEVICE")=="PIC16LF1459")) 
....................  #define __USB_1459__ 
....................  #define USB_TOTAL_RAM_SPACE  512 
....................  
....................  #define USB_RAM_START_LINEAR  0x2000 
....................  #define USB_RAM_START_TRADITIONAL  0x20 
....................  
....................  #define USB_NUM_UEP 8 
....................  #define USB_LAST_ALLOWED_ENDPOINT  (USB_NUM_UEP-1) 
....................  #define PIN_USB_DPLUS  PIN_A0 
....................  #define PIN_USB_DMINUS  PIN_A1 
.................... #else 
....................  #error Unknown PIC device, USB not supported in this library. 
.................... #endif 
....................  
.................... #if USB_EP15_TX_SIZE || USB_EP15_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  15 
.................... #elif USB_EP14_TX_SIZE || USB_EP14_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  14 
.................... #elif USB_EP13_TX_SIZE || USB_EP13_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  13 
.................... #elif USB_EP12_TX_SIZE || USB_EP12_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  12 
.................... #elif USB_EP11_TX_SIZE || USB_EP11_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  11 
.................... #elif USB_EP10_TX_SIZE || USB_EP10_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  10 
.................... #elif USB_EP9_TX_SIZE || USB_EP9_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  9 
.................... #elif USB_EP8_TX_SIZE || USB_EP8_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  8 
.................... #elif USB_EP7_TX_SIZE || USB_EP7_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  7 
.................... #elif USB_EP6_TX_SIZE || USB_EP6_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  6 
.................... #elif USB_EP5_TX_SIZE || USB_EP5_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  5 
.................... #elif USB_EP4_TX_SIZE || USB_EP4_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  4 
.................... #elif USB_EP3_TX_SIZE || USB_EP3_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  3 
.................... #elif USB_EP2_TX_SIZE || USB_EP2_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  2 
.................... #elif USB_EP1_TX_SIZE || USB_EP1_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  1 
.................... #else 
....................  #define USB_LAST_DEFINED_ENDPOINT  0 
.................... #endif 
....................  
.................... #define USB_CONTROL_REGISTER_SIZE   ((USB_LAST_DEFINED_ENDPOINT+1)*8) 
....................  
.................... #define USB_DATA_BUFFER_NEEDED (USB_EP0_TX_SIZE+USB_EP0_RX_SIZE+USB_EP1_TX_SIZE+\ 
....................                            USB_EP1_RX_SIZE+USB_EP2_TX_SIZE+USB_EP2_RX_SIZE+\ 
....................                            USB_EP3_TX_SIZE+USB_EP3_RX_SIZE+USB_EP4_TX_SIZE+\ 
....................                            USB_EP4_RX_SIZE+USB_EP5_TX_SIZE+USB_EP5_RX_SIZE+\ 
....................                            USB_EP6_TX_SIZE+USB_EP6_RX_SIZE+USB_EP7_TX_SIZE+\ 
....................                            USB_EP7_RX_SIZE+USB_EP8_TX_SIZE+USB_EP8_RX_SIZE+\ 
....................                            USB_EP9_TX_SIZE+USB_EP9_RX_SIZE+USB_EP10_TX_SIZE+\ 
....................                            USB_EP10_RX_SIZE+USB_EP11_TX_SIZE+USB_EP11_RX_SIZE+\ 
....................                            USB_EP12_TX_SIZE+USB_EP12_RX_SIZE+USB_EP13_TX_SIZE+\ 
....................                            USB_EP13_RX_SIZE+USB_EP14_TX_SIZE+USB_EP14_RX_SIZE+\ 
....................                            USB_EP15_TX_SIZE+USB_EP15_RX_SIZE) 
....................  
.................... #if defined(USB_RAM_START_LINEAR) 
....................    #if ((USB_DATA_BUFFER_NEEDED+USB_CONTROL_REGISTER_SIZE) > USB_TOTAL_RAM_SPACE) 
....................       #error You are trying to allocate more memory for endpoints than the PIC can handle 
....................    #endif 
.................... #else 
....................    #if (USB_DATA_BUFFER_NEEDED > USB_TOTAL_RAM_SPACE) 
....................       #error You are trying to allocate more memory for endpoints than the PIC can handle 
....................    #endif 
.................... #endif 
....................  
.................... #if (USB_LAST_DEFINED_ENDPOINT > USB_LAST_ALLOWED_ENDPOINT) 
....................  #error You are trying to use an invalid endpoint for this hardware! 
.................... #endif 
....................  
.................... typedef struct 
.................... { 
....................    unsigned int8 stat; 
....................    unsigned int8 cnt; 
....................    unsigned int16 addr; 
.................... } STRUCT_BD; 
....................  
.................... #if !defined(USB_BDT_START_LINEAR) 
.................... //bdt and endpoints fit into same block 
.................... struct 
.................... { 
....................    struct 
....................    { 
....................       STRUCT_BD out;    //pc -> pic 
....................       STRUCT_BD in;     //pc <- pic 
....................    } bd[USB_LAST_DEFINED_ENDPOINT+1]; 
....................    union 
....................    { 
....................       struct 
....................       { 
....................          unsigned int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................          unsigned int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................  
....................          //these buffer definitions needed for CDC library 
....................         #if USB_EP1_RX_SIZE 
....................          unsigned int8 ep1_rx_buffer[USB_EP1_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP1_TX_SIZE 
....................          unsigned int8 ep1_tx_buffer[USB_EP1_TX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_RX_SIZE 
....................          unsigned int8 ep2_rx_buffer[USB_EP2_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_TX_SIZE 
....................          unsigned int8 ep2_tx_buffer[USB_EP2_TX_SIZE]; 
....................         #endif 
....................       }; 
....................       unsigned int8 general[USB_DATA_BUFFER_NEEDED]; 
....................    } buffer; 
.................... } g_USBRAM; 
.................... #locate g_USBRAM=USB_RAM_START_TRADITIONAL 
.................... #define g_USBBDT g_USBRAM.bd 
.................... #define USB_DATA_BUFFER_LOCATION ((int8*)&g_USBRAM.buffer) 
.................... #else 
.................... //bdt and endpoints are two different blocks 
.................... struct 
.................... { 
....................    union 
....................    { 
....................       struct 
....................       { 
....................          unsigned int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................          unsigned int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................  
....................          //these buffer definitions needed for CDC library 
....................         #if USB_EP1_RX_SIZE 
....................          unsigned int8 ep1_rx_buffer[USB_EP1_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP1_TX_SIZE 
....................          unsigned int8 ep1_tx_buffer[USB_EP1_TX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_RX_SIZE 
....................          unsigned int8 ep2_rx_buffer[USB_EP2_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_TX_SIZE 
....................          unsigned int8 ep2_tx_buffer[USB_EP2_TX_SIZE]; 
....................         #endif 
....................       }; 
....................       unsigned int8 general[USB_DATA_BUFFER_NEEDED]; 
....................    } buffer; 
.................... } g_USBRAM; 
.................... #define USB_DATA_BUFFER_LOCATION ((int8*)&g_USBRAM) 
.................... struct 
.................... { 
....................       STRUCT_BD out;    //pc -> pic 
....................       STRUCT_BD in;     //pc <- pic 
.................... } g_USBBDT[USB_LAST_DEFINED_ENDPOINT+1]; 
.................... #locate g_USBBDT=USB_BDT_START_TRADITIONAL 
.................... #endif 
....................  
.................... #define usb_ep0_rx_buffer g_USBRAM.buffer.ep0_rx_buffer 
.................... #define usb_ep0_tx_buffer g_USBRAM.buffer.ep0_tx_buffer 
....................  
.................... //these buffer definitions needed for CDC library 
.................... #define usb_ep1_rx_buffer g_USBRAM.buffer.ep1_rx_buffer 
.................... #define usb_ep1_tx_buffer g_USBRAM.buffer.ep1_tx_buffer 
.................... #define usb_ep2_rx_buffer g_USBRAM.buffer.ep2_rx_buffer 
.................... #define usb_ep2_tx_buffer g_USBRAM.buffer.ep2_tx_buffer 
....................  
.................... //if you enable this it will keep a counter of the 6 possible errors the 
.................... //pic can detect.  disabling this will save you ROM, RAM and execution time. 
.................... #if !defined(USB_USE_ERROR_COUNTER) 
....................    #define USB_USE_ERROR_COUNTER FALSE 
.................... #endif 
....................  
.................... #define USB_PING_PONG_MODE_OFF   0  //no ping pong 
.................... #define USB_PING_PONG_MODE_E0    1  //ping pong endpoint 0 only 
.................... #define USB_PING_PONG_MODE_ON    2  //ping pong all endpoints 
....................  
.................... //NOTE - PING PONG MODE IS NOT SUPPORTED BY CCS! 
.................... #if !defined(USB_PING_PONG_MODE) 
....................    #define USB_PING_PONG_MODE USB_PING_PONG_MODE_OFF 
.................... #endif 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................    unsigned int ERROR_COUNTER[6]; 
.................... #endif 
....................  
....................  
.................... #byte UFRML = getenv("SFR:UFRML")   //e95 
.................... #byte UFRMH = getenv("SFR:UFRMH")   //e94 
.................... #byte UIR = getenv("SFR:UIR")   //e90 
.................... #byte UIE = getenv("SFR:UIE")   //e92 
.................... #byte UEIR = getenv("SFR:UEIR")   //e93 
.................... #byte UEIE = getenv("SFR:UEIE")   //e97 
.................... #byte U1STAT = getenv("SFR:USTAT")   //e8f 
.................... #byte UCON = getenv("SFR:UCON")   //e8e 
.................... #byte UADDR = getenv("SFR:UADDR")   //e96 
.................... #byte UCFG = getenv("SFR:UCFG")   //e91 
.................... #byte UEP0 = getenv("SFR:UEP0")   //e98 
....................  
.................... unsigned int8 USTATCopy; 
....................  
.................... unsigned int8 g_UEP[USB_NUM_UEP]; 
.................... #locate g_UEP=getenv("SFR:UEP0") 
.................... #define UEP(x) g_UEP[x] 
....................  
.................... #define BIT_SOF   6 
.................... #define BIT_STALL 5 
.................... #define BIT_IDLE  4 
.................... #define BIT_TRN   3 
.................... #define BIT_ACTV  2 
.................... #define BIT_UERR  1 
.................... #define BIT_URST  0 
....................  
.................... #BIT UIR_SOF = UIR.BIT_SOF 
.................... #BIT UIR_STALL = UIR.BIT_STALL 
.................... #BIT UIR_IDLE = UIR.BIT_IDLE 
.................... #BIT UIR_TRN = UIR.BIT_TRN 
.................... #BIT UIR_ACTV = UIR.BIT_ACTV 
.................... #BIT UIR_UERR = UIR.BIT_UERR 
.................... #BIT UIR_URST = UIR.BIT_URST 
....................  
.................... #BIT UIE_SOF = UIE.6 
.................... #BIT UIE_STALL = UIE.5 
.................... #BIT UIE_IDLE = UIE.4 
.................... #BIT UIE_TRN = UIE.3 
.................... #BIT UIE_ACTV = UIE.2 
.................... #BIT UIE_UERR = UIE.1 
.................... #BIT UIE_URST = UIE.0 
....................  
.................... #define __USB_UIF_RESET    (1<<BIT_URST) 
.................... #define __USB_UIF_ERROR    (1<<BIT_UERR) 
.................... #define __USB_UIF_ACTIVE   (1<<BIT_ACTV) 
.................... #define __USB_UIF_TOKEN    (1<<BIT_TRN) 
.................... #define __USB_UIF_IDLE     (1<<BIT_IDLE) 
.................... #define __USB_UIF_STALL    (1<<BIT_STALL) 
.................... #define __USB_UIF_SOF      (1<<BIT_SOF) 
....................  
.................... #bit UCON_PBRST=UCON.6 
.................... #bit UCON_SE0=UCON.5 
.................... #bit UCON_PKTDIS=UCON.4 
.................... #bit UCON_USBEN=UCON.3 
.................... #bit UCON_RESUME=UCON.2 
.................... #bit UCON_SUSPND=UCON.1 
....................  
.................... #if (USB_PING_PONG_MODE==USB_PING_PONG_MODE_OFF) 
....................  #define EP_BDxST_O(x)    g_USBBDT[x].out.stat 
....................  #define EP_BDxCNT_O(x)   g_USBBDT[x].out.cnt 
....................  #define EP_BDxADR_O(x)   g_USBBDT[x].out.addr 
....................  #define EP_BDxST_I(x)    g_USBBDT[x].in.stat 
....................  #define EP_BDxCNT_I(x)   g_USBBDT[x].in.cnt 
....................  #define EP_BDxADR_I(x)   g_USBBDT[x].in.addr 
.................... #else 
.................... #error Right now this driver only supports no ping pong 
.................... #endif 
....................  
.................... //See UEPn (0xF70-0xF7F) 
.................... #define ENDPT_DISABLED   0x00   //endpoint not used 
.................... #define ENDPT_IN_ONLY   0x02    //endpoint supports IN transactions only 
.................... #define ENDPT_OUT_ONLY   0x04    //endpoint supports OUT transactions only 
.................... #define ENDPT_CONTROL   0x06    //Supports IN, OUT and CONTROL transactions - Only use with EP0 
.................... #define ENDPT_NON_CONTROL 0x0E  //Supports both IN and OUT transactions 
....................  
.................... //Define the states that the USB interface can be in 
.................... enum {USB_STATE_DETACHED=0, USB_STATE_ATTACHED=1, USB_STATE_POWERED=2, USB_STATE_DEFAULT=3, 
....................     USB_STATE_ADDRESS=4, USB_STATE_CONFIGURED=5} usb_state; 
....................  
.................... //--BDendST has their PIDs upshifed 2 
.................... #define USB_PIC_PID_IN       0x24  //device to host transactions 
.................... #define USB_PIC_PID_OUT      0x04  //host to device transactions 
.................... #define USB_PIC_PID_SETUP    0x34  //host to device setup transaction 
....................  
.................... #define USTAT_IN_E0        4 
.................... #define USTAT_OUT_SETUP_E0 0 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_ERROR|__USB_UIF_RESET 
.................... #else 
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_RESET 
.................... #endif 
....................  
.................... #define __USB_UCFG_UTEYE   0x80 
.................... #define __USB_UCFG_UPUEN   0x10 
.................... #define __USB_UCFG_FSEN    0x04 
....................  
.................... #if defined(USB_EXTERNAL_PULLUPS) 
....................  #define __USB_UCFG_MY_UPUEN  0 
.................... #endif 
....................  
.................... #if defined(USB_INTERNAL_PULLUPS) 
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN 
.................... #endif 
....................  
.................... #if !defined(__USB_UCFG_MY_UPUEN) 
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN 
.................... #endif 
....................  
.................... #if USB_USE_FULL_SPEED 
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | __USB_UCFG_FSEN | USB_PING_PONG_MODE) 
.................... #else 
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | USB_PING_PONG_MODE); 
.................... #endif 
....................  
.................... #if defined(__USB_UCFG_UTRDIS) 
....................  #define __UCFG_VAL_DISABLED__    __USB_UCFG_UTRDIS 
.................... #endif 
....................  
.................... unsigned int8 __setup_0_tx_size; 
....................  
.................... //interrupt handler, specific to PIC18Fxx5x peripheral only 
.................... void usb_handle_interrupt(); 
.................... void usb_isr_rst(); 
.................... void usb_isr_uerr(); 
.................... void usb_isr_sof(void); 
.................... void usb_isr_activity(); 
.................... void usb_isr_uidle(); 
.................... void usb_isr_tok_dne(); 
.................... void usb_isr_stall(void); 
.................... void usb_init_ep0_setup(void); 
....................  
.................... #if defined(USB_ISR_POLLING) 
.................... void usb_isr(void); 
.................... #endif 
....................  
.................... //// BEGIN User Functions: 
....................  
.................... // see usb_hw_layer.h for more documentation 
.................... int1 usb_kbhit(unsigned int8 en) 
.................... { 
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_O(en),7))); 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_tbe(unsigned int8 en) 
.................... { 
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_I(en),7))); 
*
030F:  MOVLW  98
0310:  MOVLB  04
0311:  ADDWF  6E,W
0312:  MOVWF  04
0313:  MOVLW  0E
0314:  MOVWF  05
0315:  MOVF   00,F
0316:  BTFSC  03.2
0317:  GOTO   327
0318:  RLF    6E,W
0319:  MOVWF  77
031A:  RLF    77,F
031B:  RLF    77,F
031C:  MOVLW  F8
031D:  ANDWF  77,F
031E:  MOVF   77,W
031F:  ADDLW  04
0320:  MOVWF  04
0321:  MOVLW  20
0322:  MOVWF  05
0323:  MOVF   00,W
0324:  MOVWF  6F
0325:  BTFSS  6F.7
0326:  GOTO   329
0327:  MOVLW  00
0328:  GOTO   32A
0329:  MOVLW  01
032A:  MOVWF  78
032B:  MOVLB  00
032C:  RETURN
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_detach(void) 
.................... { 
....................    UCON = 0;  //disable USB hardware 
*
050F:  MOVLB  1D
0510:  CLRF   0E
....................    UIE = 0;   //disable USB interrupts 
0511:  CLRF   12
....................   #if defined(__UCFG_VAL_DISABLED__) 
....................    UCFG = __UCFG_VAL_DISABLED__; 
....................   #endif 
....................  
....................    // set D+/D- to inputs 
....................    output_float(PIN_USB_DPLUS); 
0512:  MOVLB  01
0513:  BSF    0C.0
....................    output_float(PIN_USB_DMINUS); 
0514:  BSF    0C.1
....................  
....................    usb_state = USB_STATE_DETACHED; 
0515:  CLRF   72
0516:  MOVLB  02
0517:  CLRF   3B
0518:  BTFSC  0B.7
0519:  BSF    3B.7
051A:  BCF    0B.7
....................  
....................    usb_token_reset();              //clear the chapter9 stack 
051B:  MOVLB  00
051C:  CALL   221
051D:  MOVLB  02
051E:  BTFSC  3B.7
051F:  BSF    0B.7
....................    //__usb_kbhit_status=0; 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_attach(void) 
.................... { 
....................    usb_token_reset(); 
*
0528:  MOVLB  00
0529:  CALL   221
052A:  MOVLB  02
052B:  BTFSC  3B.7
052C:  BSF    0B.7
....................    UCON = 0; 
052D:  MOVLB  1D
052E:  CLRF   0E
....................    UCFG = __UCFG_VAL_ENABLED__; 
052F:  MOVLW  14
0530:  MOVWF  11
....................    UIE = 0;                                // Mask all USB interrupts 
0531:  CLRF   12
....................    UCON_USBEN = 1;                     // Enable module & attach to bus 
0532:  BSF    0E.3
....................    usb_state = USB_STATE_ATTACHED;      // Defined in usbmmap.c & .h 
0533:  MOVLW  01
0534:  MOVWF  72
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_init_cs(void) 
.................... { 
....................    usb_detach(); 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_task(void) 
.................... { 
....................   #if defined(USB_ISR_POLLING) 
....................    if (interrupt_active(INT_USB)) 
....................    { 
....................       usb_isr(); 
....................    } 
....................   #endif 
....................  
....................   #if defined(USB_CDC_DELAYED_FLUSH) 
....................    if (usb_enumerated()) 
....................    { 
....................       usb_cdc_flush_tx_buffer(); 
....................    } 
....................   #endif 
....................  
....................    if (usb_attached()) 
....................    { 
....................       if (UCON_USBEN==0) 
*
0520:  MOVLB  1D
0521:  BTFSC  0E.3
0522:  GOTO   535
0523:  MOVLB  02
0524:  CLRF   3B
0525:  BTFSC  0B.7
0526:  BSF    3B.7
0527:  BCF    0B.7
....................       { 
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: ATTACH"); 
....................          usb_attach(); 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if (UCON_USBEN==1) 
....................       { 
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: DE-ATTACH"); 
....................          usb_detach(); 
....................       } 
....................    } 
....................  
....................    if ((usb_state == USB_STATE_ATTACHED)&&(!UCON_SE0)) 
*
0535:  DECFSZ 72,W
0536:  GOTO   544
0537:  BTFSC  0E.5
0538:  GOTO   544
....................    { 
....................       UIR=0; 
0539:  CLRF   10
....................       UIE=0; 
053A:  CLRF   12
....................      #if !defined(USB_ISR_POLLING) 
....................       enable_interrupts(INT_USB); 
053B:  MOVLB  01
053C:  BSF    12.2
....................       enable_interrupts(GLOBAL); 
053D:  MOVLW  C0
053E:  IORWF  0B,F
....................      #endif 
....................       UIE=__USB_UIF_IDLE | __USB_UIF_RESET;  //enable IDLE and RESET USB ISR 
053F:  MOVLW  11
0540:  MOVLB  1D
0541:  MOVWF  12
....................       usb_state=USB_STATE_POWERED; 
0542:  MOVLW  02
0543:  MOVWF  72
....................       debug_usb(debug_putc, "\r\n\nUSB TASK: POWERED"); 
....................    } 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_init(void) 
.................... { 
....................    usb_init_cs(); 
....................  
....................    do 
....................    { 
....................       usb_task(); 
....................    } while (usb_state != USB_STATE_POWERED); 
0544:  MOVF   72,W
0545:  SUBLW  02
0546:  BTFSS  03.2
0547:  GOTO   521
0548:  MOVLP  00
0549:  MOVLB  00
054A:  GOTO   726 (RETURN)
.................... } 
....................  
....................  
.................... // see pic18_usb.h for documentation 
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    debug_usb(debug_putc,"\r\nPUT %X %U %LU",endpoint, tgl, len); 
....................  
....................    if (usb_tbe(endpoint)) 
*
032D:  MOVLB  04
032E:  MOVF   69,W
032F:  MOVWF  6E
0330:  MOVLB  00
0331:  CALL   30F
0332:  MOVF   78,F
0333:  BTFSC  03.2
0334:  GOTO   38E
....................    { 
....................       EP_BDxCNT_I(endpoint)=len; 
0335:  MOVLB  04
0336:  RLF    69,W
0337:  MOVWF  77
0338:  RLF    77,F
0339:  RLF    77,F
033A:  MOVLW  F8
033B:  ANDWF  77,F
033C:  MOVF   77,W
033D:  ADDLW  04
033E:  ADDLW  01
033F:  MOVWF  04
0340:  MOVLW  20
0341:  MOVWF  05
0342:  MOVF   6A,W
0343:  MOVWF  00
....................  
....................       debug_display_ram(len, EP_BDxADR_I(endpoint)); 
....................  
....................      #if USB_IGNORE_TX_DTS 
....................       i=0x80; 
....................      #else 
....................       if (tgl == USB_DTS_TOGGLE) 
0344:  MOVF   6C,W
0345:  SUBLW  02
0346:  BTFSS  03.2
0347:  GOTO   35C
....................       { 
....................          i = EP_BDxST_I(endpoint); 
0348:  RLF    69,W
0349:  MOVWF  77
034A:  RLF    77,F
034B:  RLF    77,F
034C:  MOVLW  F8
034D:  ANDWF  77,F
034E:  MOVF   77,W
034F:  ADDLW  04
0350:  MOVWF  04
0351:  MOVLW  20
0352:  MOVWF  05
0353:  MOVF   00,W
0354:  MOVWF  6D
....................          if (bit_test(i,6)) 
0355:  BTFSS  6D.6
0356:  GOTO   359
....................             tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0 
0357:  CLRF   6C
0358:  GOTO   35B
....................          else 
....................             tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1 
0359:  MOVLW  01
035A:  MOVWF  6C
....................       } 
035B:  GOTO   372
....................       else if (tgl == USB_DTS_USERX) 
035C:  MOVF   6C,W
035D:  SUBLW  04
035E:  BTFSS  03.2
035F:  GOTO   372
....................       { 
....................          i = EP_BDxST_O(endpoint); 
0360:  RLF    69,W
0361:  MOVWF  77
0362:  RLF    77,F
0363:  RLF    77,F
0364:  MOVLW  F8
0365:  ANDWF  77,F
0366:  MOVF   77,W
0367:  MOVWF  04
0368:  MOVLW  20
0369:  MOVWF  05
036A:  MOVF   00,W
036B:  MOVWF  6D
....................          if (bit_test(i,6)) 
036C:  BTFSS  6D.6
036D:  GOTO   371
....................             tgl = USB_DTS_DATA1; 
036E:  MOVLW  01
036F:  MOVWF  6C
0370:  GOTO   372
....................          else 
....................             tgl = USB_DTS_DATA0; 
0371:  CLRF   6C
....................       } 
....................       if (tgl == USB_DTS_DATA1) 
0372:  DECFSZ 6C,W
0373:  GOTO   377
....................          i=0xC8;  //DATA1, UOWN 
0374:  MOVLW  C8
0375:  MOVWF  6D
0376:  GOTO   379
....................       else //if (tgl == USB_DTS_DATA0) 
....................          i=0x88; //DATA0, UOWN 
0377:  MOVLW  88
0378:  MOVWF  6D
....................      #endif 
....................  
....................       //set BC8 and BC9 
....................       if (bit_test(len,8)) {bit_set(i,0);} 
0379:  BTFSC  6B.0
037A:  BSF    6D.0
....................       if (bit_test(len,9)) {bit_set(i,1);} 
037B:  BTFSC  6B.1
037C:  BSF    6D.1
....................  
....................       debug_usb(debug_putc, " %X", i); 
....................  
....................       EP_BDxST_I(endpoint) = i;//save changes 
037D:  RLF    69,W
037E:  MOVWF  77
037F:  RLF    77,F
0380:  RLF    77,F
0381:  MOVLW  F8
0382:  ANDWF  77,F
0383:  MOVF   77,W
0384:  ADDLW  04
0385:  MOVWF  04
0386:  MOVLW  20
0387:  MOVWF  05
0388:  MOVF   6D,W
0389:  MOVWF  00
....................  
....................       //putc('!'); 
....................  
....................       return(1); 
038A:  MOVLW  01
038B:  MOVWF  78
038C:  GOTO   391
....................    } 
038D:  MOVLB  00
....................    else 
....................    { 
....................       //putc('_'); 
....................       debug_usb(debug_putc,"\r\nPUT ERR"); 
....................    } 
....................    return(0); 
038E:  MOVLW  00
038F:  MOVWF  78
0390:  MOVLB  04
0391:  MOVLB  00
0392:  RETURN
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_put_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl) 
.................... { 
....................    unsigned int8 * buff_add; 
....................  
....................    if (usb_tbe(endpoint)) 
*
0402:  MOVLB  04
0403:  MOVF   61,W
0404:  MOVWF  6E
0405:  MOVLB  00
0406:  CALL   30F
0407:  MOVF   78,F
0408:  BTFSC  03.2
0409:  GOTO   437
....................    { 
....................       buff_add = EP_BDxADR_I(endpoint); 
040A:  MOVLB  04
040B:  RLF    61,W
040C:  MOVWF  77
040D:  RLF    77,F
040E:  RLF    77,F
040F:  MOVLW  F8
0410:  ANDWF  77,F
0411:  MOVF   77,W
0412:  ADDLW  04
0413:  ADDLW  02
0414:  MOVWF  04
0415:  MOVLW  20
0416:  MOVWF  05
0417:  MOVF   00,W
0418:  MOVWF  67
0419:  MOVIW  [FSR0+01],W
041A:  MOVWF  68
....................        
....................       memcpy(buff_add, ptr, len); 
041B:  MOVF   63,W
041C:  MOVWF  05
041D:  MOVF   62,W
041E:  MOVWF  04
041F:  MOVF   64,W
0420:  MOVWF  78
0421:  BTFSC  03.2
0422:  GOTO   42B
0423:  MOVF   68,W
0424:  MOVWF  07
0425:  MOVF   67,W
0426:  MOVWF  06
0427:  MOVIW  [FSR0++],W
0428:  MOVWI  W,[FSR1++]
0429:  DECFSZ 78,F
042A:  GOTO   427
....................  
....................       return(usb_flush_in(endpoint, len, tgl)); 
042B:  MOVF   61,W
042C:  MOVWF  69
042D:  MOVF   65,W
042E:  MOVWF  6B
042F:  MOVF   64,W
0430:  MOVWF  6A
0431:  MOVF   66,W
0432:  MOVWF  6C
0433:  MOVLB  00
0434:  CALL   32D
0435:  MOVF   78,W
0436:  GOTO   439
....................    } 
....................    else 
....................    { 
....................       //putc('-'); 
....................       //printf("%X", EP_BDxST_I(endpoint)); 
....................       debug_usb(debug_putc,"\r\nPUT ERR"); 
....................    } 
....................  
....................    return(0); 
0437:  MOVLW  00
0438:  MOVWF  78
0439:  RETURN
.................... } 
....................  
.................... // see pic18_usb.h for documentation 
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl) 
.................... { 
....................    unsigned int8 i; 
....................    unsigned int16 len; 
....................  
....................   #if USB_IGNORE_RX_DTS 
....................    if (tgl == USB_DTS_STALL) 
....................    { 
....................       debug_usb(debug_putc, '*'); 
....................       EP_BDxCNT_O(endpoint) = 0x84; 
....................       EP_BDxST_I(endpoint) = 0x84; 
....................       return; 
....................    } 
....................    else 
....................       i=0x80; 
....................   #else 
....................    i = EP_BDxST_O(endpoint); 
*
02AF:  MOVLB  04
02B0:  RLF    61,W
02B1:  MOVWF  77
02B2:  RLF    77,F
02B3:  RLF    77,F
02B4:  MOVLW  F8
02B5:  ANDWF  77,F
02B6:  MOVF   77,W
02B7:  MOVWF  04
02B8:  MOVLW  20
02B9:  MOVWF  05
02BA:  MOVF   00,W
02BB:  MOVWF  63
....................    if (tgl == USB_DTS_TOGGLE) 
02BC:  MOVF   62,W
02BD:  SUBLW  02
02BE:  BTFSS  03.2
02BF:  GOTO   2C6
....................    { 
....................       if (bit_test(i,6)) 
02C0:  BTFSS  63.6
02C1:  GOTO   2C4
....................          tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0 
02C2:  CLRF   62
02C3:  GOTO   2C6
....................       else 
....................          tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1 
02C4:  MOVLW  01
02C5:  MOVWF  62
....................    } 
....................    if (tgl == USB_DTS_STALL) 
02C6:  MOVF   62,W
02C7:  SUBLW  03
02C8:  BTFSS  03.2
02C9:  GOTO   2DA
....................    { 
....................       i = 0x84; 
02CA:  MOVLW  84
02CB:  MOVWF  63
....................       EP_BDxST_I(endpoint) = 0x84; //stall both in and out endpoints 
02CC:  RLF    61,W
02CD:  MOVWF  77
02CE:  RLF    77,F
02CF:  RLF    77,F
02D0:  MOVLW  F8
02D1:  ANDWF  77,F
02D2:  MOVF   77,W
02D3:  ADDLW  04
02D4:  MOVWF  04
02D5:  MOVLW  20
02D6:  MOVWF  05
02D7:  MOVLW  84
02D8:  MOVWF  00
....................    } 
02D9:  GOTO   2E1
....................    else if (tgl == USB_DTS_DATA1) 
02DA:  DECFSZ 62,W
02DB:  GOTO   2DF
....................       i = 0xC8;  //DATA1, UOWN 
02DC:  MOVLW  C8
02DD:  MOVWF  63
02DE:  GOTO   2E1
....................    else //if (tgl == USB_DTS_DATA0) 
....................       i = 0x88; //DATA0, UOWN 
02DF:  MOVLW  88
02E0:  MOVWF  63
....................   #endif 
....................  
....................    //bit_clear(__usb_kbhit_status,endpoint); 
....................  
....................    len = usb_ep_rx_size[endpoint]; 
02E1:  BCF    03.0
02E2:  RLF    61,W
02E3:  MOVWF  66
02E4:  INCF   66,W
02E5:  MOVLB  00
02E6:  CALL   0BF
02E7:  MOVWF  7A
02E8:  MOVLB  04
02E9:  MOVF   66,W
02EA:  MOVLB  00
02EB:  CALL   0BF
02EC:  MOVLB  04
02ED:  MOVWF  64
02EE:  MOVF   7A,W
02EF:  MOVWF  65
....................    EP_BDxCNT_O(endpoint) = len; 
02F0:  RLF    61,W
02F1:  MOVWF  77
02F2:  RLF    77,F
02F3:  RLF    77,F
02F4:  MOVLW  F8
02F5:  ANDWF  77,F
02F6:  MOVF   77,W
02F7:  ADDLW  01
02F8:  MOVWF  04
02F9:  MOVLW  20
02FA:  MOVWF  05
02FB:  MOVF   64,W
02FC:  MOVWF  00
....................    if (bit_test(len,8)) {bit_set(i,0);} 
02FD:  BTFSC  65.0
02FE:  BSF    63.0
....................    if (bit_test(len,9)) {bit_set(i,1);} 
02FF:  BTFSC  65.1
0300:  BSF    63.1
....................  
....................    EP_BDxST_O(endpoint) = i; 
0301:  RLF    61,W
0302:  MOVWF  77
0303:  RLF    77,F
0304:  RLF    77,F
0305:  MOVLW  F8
0306:  ANDWF  77,F
0307:  MOVF   77,W
0308:  MOVWF  04
0309:  MOVLW  20
030A:  MOVWF  05
030B:  MOVF   63,W
030C:  MOVWF  00
030D:  MOVLB  00
030E:  RETURN
.................... } 
....................  
.................... // see pic18_usb.h for documentation 
.................... unsigned int16 usb_rx_packet_size(unsigned int8 endpoint) 
.................... { 
....................    return(EP_BDxCNT_O(endpoint)); 
*
03E6:  RLF    61,W
03E7:  MOVWF  77
03E8:  RLF    77,F
03E9:  RLF    77,F
03EA:  MOVLW  F8
03EB:  ANDWF  77,F
03EC:  MOVF   77,W
03ED:  ADDLW  01
03EE:  MOVWF  04
03EF:  MOVLW  20
03F0:  MOVWF  05
03F1:  CLRF   7A
03F2:  MOVF   00,W
03F3:  MOVWF  78
03F4:  MOVF   7A,W
03F5:  MOVWF  79
.................... } 
....................  
.................... /// END User Functions 
....................  
....................  
.................... /// BEGIN Hardware layer functions required by USB. 
....................  
.................... /***************************************************************************** 
.................... /* usb_get_packet_buffer(endpoint, *ptr, max) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: the amount of data taken from the buffer. 
.................... /* 
.................... /* Summary: Gets a packet of data from the USB buffer and puts into local PIC 
.................... /*          RAM. 
.................... /*          Does not mark the endpoint as ready for more data.  Once you are 
.................... /*          done with data, call usb_flush_out() to mark the endpoint ready 
.................... /*          to receive more data. 
.................... /* 
.................... /*****************************************************************************/ 
.................... static int16 usb_get_packet_buffer(int8 endpoint, int8 *ptr, int16 max) 
.................... { 
....................    unsigned int8 * al; 
....................    unsigned int8 st; 
....................    unsigned int16 i; 
....................  
....................    al = EP_BDxADR_O(endpoint); 
....................    i = EP_BDxCNT_O(endpoint); 
....................    st = EP_BDxST_O(endpoint); 
....................  
....................    //read BC8 and BC9 
....................    if (bit_test(st,0)) {bit_set(i,8);} 
....................    if (bit_test(st,1)) {bit_set(i,9);} 
....................  
....................    if (i < max) {max = i;} 
....................  
....................    memcpy(ptr, al ,max); 
....................  
....................    return(max); 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... unsigned int16 usb_get_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max) 
.................... { 
....................    max = usb_get_packet_buffer(endpoint, ptr, max); 
....................    usb_flush_out(endpoint, USB_DTS_TOGGLE); 
....................  
....................    return(max); 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_stall_ep(unsigned int8 endpoint) 
.................... { 
....................    int1 direction; 
....................  
....................    direction = bit_test(endpoint,7); 
*
0B10:  BCF    61.0
0B11:  BTFSC  60.7
0B12:  BSF    61.0
....................    endpoint &= 0x7F; 
0B13:  BCF    60.7
....................  
....................    if (direction) 
0B14:  BTFSS  61.0
0B15:  GOTO   324
....................    { 
....................       EP_BDxST_I(endpoint) = 0x84; 
0B16:  RLF    60,W
0B17:  MOVWF  77
0B18:  RLF    77,F
0B19:  RLF    77,F
0B1A:  MOVLW  F8
0B1B:  ANDWF  77,F
0B1C:  MOVF   77,W
0B1D:  ADDLW  04
0B1E:  MOVWF  04
0B1F:  MOVLW  20
0B20:  MOVWF  05
0B21:  MOVLW  84
0B22:  MOVWF  00
....................    } 
0B23:  GOTO   330
....................    else 
....................    { 
....................       EP_BDxST_O(endpoint) = 0x84; 
0B24:  RLF    60,W
0B25:  MOVWF  77
0B26:  RLF    77,F
0B27:  RLF    77,F
0B28:  MOVLW  F8
0B29:  ANDWF  77,F
0B2A:  MOVF   77,W
0B2B:  MOVWF  04
0B2C:  MOVLW  20
0B2D:  MOVWF  05
0B2E:  MOVLW  84
0B2F:  MOVWF  00
....................    } 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_unstall_ep(unsigned int8 endpoint) 
.................... { 
....................    int1 direction; 
....................  
....................    direction = bit_test(endpoint,7); 
*
0AE8:  BCF    61.0
0AE9:  BTFSC  60.7
0AEA:  BSF    61.0
....................    endpoint &= 0x7F; 
0AEB:  BCF    60.7
....................  
....................    if (direction) 
0AEC:  BTFSS  61.0
0AED:  GOTO   2FC
....................    { 
....................      #if USB_IGNORE_RX_DTS 
....................       EP_BDxST_I(endpoint) = 0x80; 
....................      #else 
....................       EP_BDxST_I(endpoint) = 0x88; 
0AEE:  RLF    60,W
0AEF:  MOVWF  77
0AF0:  RLF    77,F
0AF1:  RLF    77,F
0AF2:  MOVLW  F8
0AF3:  ANDWF  77,F
0AF4:  MOVF   77,W
0AF5:  ADDLW  04
0AF6:  MOVWF  04
0AF7:  MOVLW  20
0AF8:  MOVWF  05
0AF9:  MOVLW  88
0AFA:  MOVWF  00
....................      #endif 
....................    } 
0AFB:  GOTO   307
....................    else 
....................    { 
....................       EP_BDxST_O(endpoint) = 0x00; 
0AFC:  RLF    60,W
0AFD:  MOVWF  77
0AFE:  RLF    77,F
0AFF:  RLF    77,F
0B00:  MOVLW  F8
0B01:  ANDWF  77,F
0B02:  MOVF   77,W
0B03:  MOVWF  04
0B04:  MOVLW  20
0B05:  MOVWF  05
0B06:  CLRF   00
....................    } 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_endpoint_stalled(unsigned int8 endpoint) 
.................... { 
....................    int1 direction; 
....................    unsigned int8 st; 
....................  
....................    direction = bit_test(endpoint,7); 
*
0B3B:  BCF    61.0
0B3C:  BTFSC  60.7
0B3D:  BSF    61.0
....................    endpoint &= 0x7F; 
0B3E:  BCF    60.7
....................  
....................    if (direction) 
0B3F:  BTFSS  61.0
0B40:  GOTO   34F
....................    { 
....................       st=EP_BDxST_I(endpoint); 
0B41:  RLF    60,W
0B42:  MOVWF  77
0B43:  RLF    77,F
0B44:  RLF    77,F
0B45:  MOVLW  F8
0B46:  ANDWF  77,F
0B47:  MOVF   77,W
0B48:  ADDLW  04
0B49:  MOVWF  04
0B4A:  MOVLW  20
0B4B:  MOVWF  05
0B4C:  MOVF   00,W
0B4D:  MOVWF  62
....................    } 
0B4E:  GOTO   35B
....................    else 
....................    { 
....................       st=EP_BDxST_O(endpoint); 
0B4F:  RLF    60,W
0B50:  MOVWF  77
0B51:  RLF    77,F
0B52:  RLF    77,F
0B53:  MOVLW  F8
0B54:  ANDWF  77,F
0B55:  MOVF   77,W
0B56:  MOVWF  04
0B57:  MOVLW  20
0B58:  MOVWF  05
0B59:  MOVF   00,W
0B5A:  MOVWF  62
....................    } 
....................  
....................    return(bit_test(st,7) && bit_test(st,2)); 
0B5B:  BTFSS  62.7
0B5C:  GOTO   35F
0B5D:  BTFSC  62.2
0B5E:  GOTO   361
0B5F:  MOVLW  00
0B60:  GOTO   362
0B61:  MOVLW  01
0B62:  MOVWF  78
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_set_address(unsigned int8 address) 
.................... { 
....................    UADDR = address; 
*
0463:  MOVF   61,W
0464:  MOVLB  1D
0465:  MOVWF  16
....................  
....................    if (address) 
0466:  MOVLB  04
0467:  MOVF   61,F
0468:  BTFSC  03.2
0469:  GOTO   46D
....................    { 
....................       usb_state = USB_STATE_ADDRESS; 
046A:  MOVLW  04
046B:  MOVWF  72
....................    } 
046C:  GOTO   46F
....................    else 
....................    { 
....................       usb_state = USB_STATE_POWERED; 
046D:  MOVLW  02
046E:  MOVWF  72
046F:  MOVLB  02
0470:  MOVLB  00
....................    } 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_set_configured(unsigned int8 config) 
.................... { 
....................    unsigned int8 en; 
....................    unsigned int16 addy; 
....................    unsigned int8 new_uep; 
....................    unsigned int16 len; 
....................    unsigned int8 i; 
....................  
....................    if (config == 0) 
*
098B:  MOVF   60,F
098C:  BTFSS  03.2
098D:  GOTO   196
....................    { 
....................       // if config=0 then set addressed state 
....................       usb_state = USB_STATE_ADDRESS; 
098E:  MOVLW  04
098F:  MOVWF  72
....................       usb_disable_endpoints(); 
0990:  MOVLP  00
0991:  MOVLB  00
0992:  CALL   1E8
0993:  MOVLP  08
....................    } 
0994:  GOTO   266
0995:  MOVLB  04
....................    else 
....................    { 
....................       // else set configed state 
....................       usb_state = USB_STATE_CONFIGURED; 
0996:  MOVLW  05
0997:  MOVWF  72
....................       addy = (unsigned int16)USB_DATA_BUFFER_LOCATION+(2*USB_MAX_EP0_PACKET_LENGTH); 
0998:  MOVLW  20
0999:  MOVWF  63
099A:  MOVLW  28
099B:  MOVWF  62
....................       for (en=1; en<USB_NUM_UEP; en++) 
099C:  MOVLW  01
099D:  MOVWF  61
099E:  MOVF   61,W
099F:  SUBLW  07
09A0:  BTFSS  03.0
09A1:  GOTO   265
....................       { 
....................          // enable and config endpoints based upon user configuration 
....................          usb_disable_endpoint(en); 
09A2:  MOVF   61,W
09A3:  MOVWF  69
09A4:  MOVLP  00
09A5:  MOVLB  00
09A6:  CALL   1C0
09A7:  MOVLP  08
....................          new_uep = 0; 
09A8:  MOVLB  04
09A9:  CLRF   64
....................          if (usb_ep_rx_type[en] != USB_ENABLE_DISABLED) 
09AA:  MOVF   61,W
09AB:  MOVLP  00
09AC:  MOVLB  00
09AD:  CALL   08D
09AE:  MOVLP  08
09AF:  SUBLW  FF
09B0:  BTFSC  03.2
09B1:  GOTO   20A
....................          { 
....................             new_uep = 0x04; 
09B2:  MOVLW  04
09B3:  MOVLB  04
09B4:  MOVWF  64
....................             len = usb_ep_rx_size[en]; 
09B5:  BCF    03.0
09B6:  RLF    61,W
09B7:  MOVWF  68
09B8:  INCF   68,W
09B9:  MOVLP  00
09BA:  MOVLB  00
09BB:  CALL   0BF
09BC:  MOVLP  08
09BD:  MOVWF  7A
09BE:  MOVLB  04
09BF:  MOVF   68,W
09C0:  MOVLP  00
09C1:  MOVLB  00
09C2:  CALL   0BF
09C3:  MOVLP  08
09C4:  MOVLB  04
09C5:  MOVWF  65
09C6:  MOVF   7A,W
09C7:  MOVWF  66
....................             EP_BDxCNT_O(en) = len; 
09C8:  RLF    61,W
09C9:  MOVWF  77
09CA:  RLF    77,F
09CB:  RLF    77,F
09CC:  MOVLW  F8
09CD:  ANDWF  77,F
09CE:  MOVF   77,W
09CF:  ADDLW  01
09D0:  MOVWF  04
09D1:  MOVLW  20
09D2:  MOVWF  05
09D3:  MOVF   65,W
09D4:  MOVWF  00
....................             EP_BDxADR_O(en) = addy; 
09D5:  RLF    61,W
09D6:  MOVWF  77
09D7:  RLF    77,F
09D8:  RLF    77,F
09D9:  MOVLW  F8
09DA:  ANDWF  77,F
09DB:  MOVF   77,W
09DC:  ADDLW  02
09DD:  MOVWF  04
09DE:  MOVLW  20
09DF:  MOVWF  05
09E0:  MOVF   62,W
09E1:  MOVWF  00
09E2:  MOVF   63,W
09E3:  MOVWI  W,[FSR0+01]
....................             addy += usb_ep_rx_size[en]; 
09E4:  BCF    03.0
09E5:  RLF    61,W
09E6:  MOVWF  68
09E7:  INCF   68,W
09E8:  MOVLP  00
09E9:  MOVLB  00
09EA:  CALL   0BF
09EB:  MOVLP  08
09EC:  MOVWF  7A
09ED:  MOVLB  04
09EE:  MOVF   68,W
09EF:  MOVLP  00
09F0:  MOVLB  00
09F1:  CALL   0BF
09F2:  MOVLP  08
09F3:  MOVLB  04
09F4:  ADDWF  62,F
09F5:  MOVF   7A,W
09F6:  ADDWFC 63,F
....................            #if USB_IGNORE_RX_DTS 
....................             i = 0x80; 
....................            #else 
....................             i = 0x88; 
09F7:  MOVLW  88
09F8:  MOVWF  67
....................            #endif 
....................             if (bit_test(len,8)) {bit_set(i,0);} 
09F9:  BTFSC  66.0
09FA:  BSF    67.0
....................             if (bit_test(len,9)) {bit_set(i,1);} 
09FB:  BTFSC  66.1
09FC:  BSF    67.1
....................             EP_BDxST_O(en) = i; 
09FD:  RLF    61,W
09FE:  MOVWF  77
09FF:  RLF    77,F
0A00:  RLF    77,F
0A01:  MOVLW  F8
0A02:  ANDWF  77,F
0A03:  MOVF   77,W
0A04:  MOVWF  04
0A05:  MOVLW  20
0A06:  MOVWF  05
0A07:  MOVF   67,W
0A08:  MOVWF  00
0A09:  MOVLB  00
....................          } 
....................          if (usb_ep_tx_type[en] != USB_ENABLE_DISABLED) 
0A0A:  MOVLB  04
0A0B:  MOVF   61,W
0A0C:  MOVLP  00
0A0D:  MOVLB  00
0A0E:  CALL   07C
0A0F:  MOVLP  08
0A10:  SUBLW  FF
0A11:  BTFSC  03.2
0A12:  GOTO   246
....................          { 
....................             new_uep |= 0x02; 
0A13:  MOVLB  04
0A14:  BSF    64.1
....................             EP_BDxADR_I(en) = addy; 
0A15:  RLF    61,W
0A16:  MOVWF  77
0A17:  RLF    77,F
0A18:  RLF    77,F
0A19:  MOVLW  F8
0A1A:  ANDWF  77,F
0A1B:  MOVF   77,W
0A1C:  ADDLW  04
0A1D:  ADDLW  02
0A1E:  MOVWF  04
0A1F:  MOVLW  20
0A20:  MOVWF  05
0A21:  MOVF   62,W
0A22:  MOVWF  00
0A23:  MOVF   63,W
0A24:  MOVWI  W,[FSR0+01]
....................             addy += usb_ep_tx_size[en]; 
0A25:  BCF    03.0
0A26:  RLF    61,W
0A27:  MOVWF  68
0A28:  INCF   68,W
0A29:  MOVLP  00
0A2A:  MOVLB  00
0A2B:  CALL   09E
0A2C:  MOVLP  08
0A2D:  MOVWF  7A
0A2E:  MOVLB  04
0A2F:  MOVF   68,W
0A30:  MOVLP  00
0A31:  MOVLB  00
0A32:  CALL   09E
0A33:  MOVLP  08
0A34:  MOVLB  04
0A35:  ADDWF  62,F
0A36:  MOVF   7A,W
0A37:  ADDWFC 63,F
....................             EP_BDxST_I(en) = 0x40; 
0A38:  RLF    61,W
0A39:  MOVWF  77
0A3A:  RLF    77,F
0A3B:  RLF    77,F
0A3C:  MOVLW  F8
0A3D:  ANDWF  77,F
0A3E:  MOVF   77,W
0A3F:  ADDLW  04
0A40:  MOVWF  04
0A41:  MOVLW  20
0A42:  MOVWF  05
0A43:  MOVLW  40
0A44:  MOVWF  00
0A45:  MOVLB  00
....................          } 
....................          if (new_uep == 0x06) {new_uep = 0x0E;} 
0A46:  MOVLB  04
0A47:  MOVF   64,W
0A48:  SUBLW  06
0A49:  BTFSS  03.2
0A4A:  GOTO   24D
0A4B:  MOVLW  0E
0A4C:  MOVWF  64
....................          if ((new_uep != 0) && (usb_ep_tx_type[en] != USB_ENABLE_ISOCHRONOUS)) {new_uep |= 0x10;} 
0A4D:  MOVF   64,F
0A4E:  BTFSC  03.2
0A4F:  GOTO   25C
0A50:  MOVF   61,W
0A51:  MOVLP  00
0A52:  MOVLB  00
0A53:  CALL   07C
0A54:  MOVLP  08
0A55:  SUBLW  01
0A56:  BTFSS  03.2
0A57:  GOTO   25A
0A58:  MOVLB  04
0A59:  GOTO   25C
0A5A:  MOVLB  04
0A5B:  BSF    64.4
....................  
....................          UEP(en) = new_uep; 
0A5C:  MOVLW  98
0A5D:  ADDWF  61,W
0A5E:  MOVWF  04
0A5F:  MOVLW  0E
0A60:  MOVWF  05
0A61:  MOVF   64,W
0A62:  MOVWF  00
0A63:  INCF   61,F
0A64:  GOTO   19E
0A65:  MOVLB  00
....................       } 
....................    } 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_disable_endpoint(unsigned int8 en) 
.................... { 
....................    UEP(en) = ENDPT_DISABLED; 
*
01C0:  MOVLW  98
01C1:  MOVLB  04
01C2:  ADDWF  69,W
01C3:  MOVWF  04
01C4:  MOVLW  0E
01C5:  MOVWF  05
01C6:  CLRF   00
....................  
....................    if (usb_endpoint_is_valid(en)) 
01C7:  MOVF   69,W
01C8:  MOVWF  6A
01C9:  MOVLB  00
01CA:  CALL   198
01CB:  MOVF   78,F
01CC:  BTFSC  03.2
01CD:  GOTO   1E6
....................    { 
....................       EP_BDxST_O(en) = 0;   //clear state, deque if necessary 
01CE:  MOVLB  04
01CF:  RLF    69,W
01D0:  MOVWF  77
01D1:  RLF    77,F
01D2:  RLF    77,F
01D3:  MOVLW  F8
01D4:  ANDWF  77,F
01D5:  MOVF   77,W
01D6:  MOVWF  04
01D7:  MOVLW  20
01D8:  MOVWF  05
01D9:  CLRF   00
....................       EP_BDxST_I(en) = 0;   //clear state, deque if necessary 
01DA:  RLF    69,W
01DB:  MOVWF  77
01DC:  RLF    77,F
01DD:  RLF    77,F
01DE:  MOVLW  F8
01DF:  ANDWF  77,F
01E0:  MOVF   77,W
01E1:  ADDLW  04
01E2:  MOVWF  04
01E3:  MOVLW  20
01E4:  MOVWF  05
01E5:  CLRF   00
01E6:  MOVLB  00
....................    } 
01E7:  RETURN
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_disable_endpoints(void) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    for (i=1; i<USB_NUM_UEP; i++) 
01E8:  MOVLW  01
01E9:  MOVLB  04
01EA:  MOVWF  68
01EB:  MOVF   68,W
01EC:  SUBLW  07
01ED:  BTFSS  03.0
01EE:  GOTO   1F6
....................       usb_disable_endpoint(i); 
01EF:  MOVF   68,W
01F0:  MOVWF  69
01F1:  MOVLB  00
01F2:  CALL   1C0
01F3:  MOVLB  04
01F4:  INCF   68,F
01F5:  GOTO   1EB
01F6:  MOVLB  00
01F7:  RETURN
....................  
....................    //__usb_kbhit_status=0; 
.................... } 
....................  
.................... /// END Hardware layer functions required by USB.C 
....................  
....................  
.................... /// BEGIN USB Interrupt Service Routine 
....................  
.................... static void usb_clear_trn(void) 
.................... { 
....................    //UIR_TRN = 0; 
....................    //delay_cycles(6); 
....................    UIR &= ~(1 << BIT_TRN); 
*
023D:  MOVLB  1D
023E:  BCF    10.3
023F:  MOVLB  00
0240:  RETURN
.................... } 
....................  
.................... /***************************************************************************** 
.................... /* usb_handle_interrupt() 
.................... /* 
.................... /* Summary: Checks the interrupt, and acts upon event.  Processing finished 
.................... /*          tokens is the majority of this code, and is handled by usb.c 
.................... /* 
.................... /* NOTE: If you wish to change to a polling method (and not an interrupt 
.................... /*       method), then you must call this function rapidly.  If there is more 
.................... /*       than 10ms latency the PC may think the USB device is stalled and 
.................... /*       disable it. 
.................... /*       To switch to a polling method, remove the #int_usb line above this 
.................... /*       fuction.  Also, goto usb_init() and remove the code that enables the 
.................... /*       USB interrupt. 
.................... /******************************************************************************/ 
.................... #if !defined(USB_ISR_POLLING) && !defined(USB_NO_ISR_PREPROCESSOR) 
.................... #int_usb NOCLEAR 
.................... #endif 
.................... void usb_isr(void) 
.................... { 
....................    //unsigned int8 TRNAttempts; 
....................  
....................    clear_interrupt(INT_USB); 
*
0800:  BCF    12.2
....................  
....................    if (usb_state == USB_STATE_DETACHED) return;   //should never happen, though 
0801:  MOVF   72,F
0802:  BTFSC  03.2
0803:  GOTO   468
....................    if (UIR) 
0804:  MOVLB  1D
0805:  MOVF   10,F
0806:  BTFSC  03.2
0807:  GOTO   467
....................    { 
....................       debug_usb(debug_putc,"\r\n\n[%X] ",UIR); 
....................        
....................       //activity detected.  (only enable after sleep) 
....................       if (UIR_ACTV && UIE_ACTV) {usb_isr_activity();} 
0808:  BTFSS  10.2
0809:  GOTO   012
080A:  BTFSS  12.2
080B:  GOTO   012
....................  
....................       if (UCON_SUSPND) return; 
*
0812:  BTFSS  0E.1
0813:  GOTO   017
0814:  MOVLB  00
0815:  GOTO   468
0816:  MOVLB  1D
....................  
....................       if (UIR_STALL && UIE_STALL) {usb_isr_stall();}        //a stall handshake was sent 
0817:  BTFSS  10.5
0818:  GOTO   024
0819:  BTFSS  12.5
081A:  GOTO   024
....................  
....................       if (UIR_UERR && UIE_UERR) {usb_isr_uerr();}          //error has been detected 
*
0824:  BTFSS  10.1
0825:  GOTO   02A
0826:  BTFSS  12.1
0827:  GOTO   02A
....................  
....................       if (UIR_URST && UIE_URST) {usb_isr_rst();}        //usb reset has been detected 
*
082A:  BTFSS  10.0
082B:  GOTO   04F
082C:  BTFSS  12.0
082D:  GOTO   04F
....................  
....................       if (UIR_IDLE && UIE_IDLE) {usb_isr_uidle();}        //idle time, we can go to sleep 
*
084F:  BTFSS  10.4
0850:  GOTO   056
0851:  BTFSS  12.4
0852:  GOTO   056
....................  
....................       if (UIR_SOF && UIE_SOF) {usb_isr_sof();} 
*
0856:  BTFSS  10.6
0857:  GOTO   05A
0858:  BTFSC  12.6
....................        
....................       //TRNAttempts = 0; 
....................       //do 
....................       while (UIR_TRN && UIE_TRN)  
*
085A:  BTFSS  10.3
085B:  GOTO   467
085C:  BTFSS  12.3
085D:  GOTO   467
....................       { 
....................          //if (UIR_TRN && UIE_TRN) 
....................          { 
....................             USTATCopy = U1STAT; 
085E:  MOVF   0F,W
085F:  MOVWF  71
....................             usb_clear_trn(); 
0860:  MOVLP  00
0861:  MOVLB  00
0862:  CALL   23D
0863:  MOVLP  08
....................             usb_isr_tok_dne(); 
....................          } 
....................          //else 
....................          //   break; 
....................       }  
....................       //while (TRNAttempts++ < 4); 
....................  
....................      #if defined(USB_CDC_ISR) 
*
0C65:  MOVLB  1D
0C66:  GOTO   05A
0C67:  MOVLB  00
....................       //has to be done here, can't be done until TRN is empty. 
....................       if (usb_cdc_kbhit()) 
....................       { 
....................          USB_CDC_ISR(); 
....................       } 
....................      #endif 
....................    } 
0C68:  MOVLP  00
0C69:  GOTO   031
.................... } 
....................  
.................... // SOF interrupt not handled.  user must add this depending on application 
.................... void usb_isr_sof(void) 
.................... { 
....................    debug_usb(debug_putc, "\r\nSOF"); 
....................  
....................    //UIR_SOF = 0; 
....................    UIR &= ~(1 << BIT_SOF); 
*
0859:  BCF    10.6
.................... } 
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_rst() 
.................... /* 
.................... /* Summary: The host (computer) sent us a RESET command.  Reset USB device 
.................... /*          and token handler code to initial state. 
.................... /* 
.................... /******************************************************************************/ 
.................... void usb_isr_rst(void) 
.................... { 
....................    debug_usb(debug_putc,"R"); 
....................  
....................    UEIR = 0; 
*
082E:  CLRF   13
....................    UIR = 0; 
082F:  CLRF   10
....................    UEIE = 0x9F; 
0830:  MOVLW  9F
0831:  MOVWF  17
....................    UIE = STANDARD_INTS & ~__USB_UIF_ACTIVE; 
0832:  MOVLW  3D
0833:  MOVWF  12
....................  
....................    UADDR = 0; 
0834:  CLRF   16
....................  
....................    usb_disable_endpoints(); 
0835:  MOVLP  00
0836:  MOVLB  00
0837:  CALL   1E8
0838:  MOVLP  08
....................  
....................    usb_token_reset(); 
0839:  MOVLP  00
083A:  CALL   221
083B:  MOVLP  08
....................  
....................    UEP(0) = ENDPT_CONTROL | 0x10; 
083C:  MOVLW  16
083D:  MOVLB  1D
083E:  MOVWF  18
....................  
....................    while (UIR_TRN) 
083F:  BTFSS  10.3
0840:  GOTO   047
....................    { 
....................       usb_clear_trn(); 
0841:  MOVLP  00
0842:  MOVLB  00
0843:  CALL   23D
0844:  MOVLP  08
0845:  MOVLB  1D
0846:  GOTO   03F
....................    } 
....................  
....................    UCON_PKTDIS = 0; //SIE token and packet processing enabled 
0847:  BCF    0E.4
....................  
....................    usb_init_ep0_setup(); 
0848:  MOVLP  00
0849:  MOVLB  00
084A:  CALL   183
084B:  MOVLP  08
....................  
....................    usb_state = USB_STATE_DEFAULT; //put usb mcu into default state 
084C:  MOVLW  03
084D:  MOVWF  72
084E:  MOVLB  1D
.................... } 
....................  
.................... /***************************************************************************** 
.................... /* usb_init_ep0_setup() 
.................... /* 
.................... /* Summary: Configure EP0 to receive setup packets 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init_ep0_setup(void) 
.................... { 
....................     EP_BDxCNT_O(0) = USB_MAX_EP0_PACKET_LENGTH; 
*
0183:  MOVLW  08
0184:  MOVWF  21
....................  
....................     EP_BDxADR_O(0) = USB_DATA_BUFFER_LOCATION; 
0185:  MOVLW  20
0186:  MOVLB  04
0187:  MOVWF  5F
0188:  MOVLW  18
0189:  MOVWF  5E
018A:  MOVF   5F,W
018B:  MOVLB  00
018C:  MOVWF  23
018D:  MOVLB  04
018E:  MOVF   5E,W
018F:  MOVLB  00
0190:  MOVWF  22
....................  
....................    #if USB_IGNORE_RX_DTS 
....................     EP_BDxST_O(0) = 0x80; //give control to SIE, data toggle synch off 
....................    #else 
....................     EP_BDxST_O(0) = 0x88; //give control to SIE, DATA0, data toggle synch on 
0191:  MOVLW  88
0192:  MOVWF  20
....................    #endif 
....................  
....................     EP_BDxST_I(0) = 0; 
0193:  CLRF   24
....................  
....................     EP_BDxADR_I(0) = USB_DATA_BUFFER_LOCATION + (int16)USB_MAX_EP0_PACKET_LENGTH; 
0194:  MOVLW  20
0195:  MOVWF  27
0196:  MOVWF  26
0197:  RETURN
.................... } 
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_uerr() 
.................... /* 
.................... /* Summary: The USB peripheral had an error.  If user specified, error counter 
.................... /*          will incerement.  If having problems check the status of these 8 bytes. 
.................... /* 
.................... /* NOTE: This code is not enabled by default. 
.................... /********************************************************************************/ 
.................... void usb_isr_uerr(void) 
.................... { 
....................   #if USB_USE_ERROR_COUNTER 
....................    int ints; 
....................   #endif 
....................  
....................    debug_usb(debug_putc,"E %X ",UEIR); 
....................  
....................   #if USB_USE_ERROR_COUNTER 
....................    ints=UEIR & UEIE; //mask off the flags with the ones that are enabled 
....................  
....................    if ( bit_test(ints,0) ) 
....................    { 
....................       //increment pid_error counter 
....................       debug_usb(debug_putc,"PID "); 
....................       ERROR_COUNTER[0]++; 
....................    } 
....................  
....................    if ( bit_test(ints,1) ) 
....................    { 
....................       //increment crc5 error counter 
....................       debug_usb(debug_putc,"CRC5 "); 
....................       ERROR_COUNTER[1]++; 
....................    } 
....................  
....................    if ( bit_test(ints,2) ) 
....................    { 
....................       //increment crc16 error counter 
....................       debug_usb(debug_putc,"CRC16 "); 
....................       ERROR_COUNTER[2]++; 
....................    } 
....................  
....................    if ( bit_test(ints,3) ) 
....................    { 
....................       //increment dfn8 error counter 
....................       debug_usb(debug_putc,"DFN8 "); 
....................       ERROR_COUNTER[3]++; 
....................    } 
....................  
....................    if ( bit_test(ints,4) ) 
....................    { 
....................       //increment bto error counter 
....................       debug_usb(debug_putc,"BTO "); 
....................       ERROR_COUNTER[4]++; 
....................    } 
....................  
....................    if ( bit_test(ints,7) ) 
....................    { 
....................       //increment bts error counter 
....................       debug_usb(debug_putc,"BTS "); 
....................       ERROR_COUNTER[5]++; 
....................    } 
....................   #endif 
....................  
....................    UEIR = 0; 
*
0828:  CLRF   13
....................  
....................    //UIR_UERR = 0; 
....................    UIR &= ~(1 << BIT_UERR); 
0829:  BCF    10.1
.................... } 
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_uidle() 
.................... /* 
.................... /* Summary: USB peripheral detected IDLE.  Put the USB peripheral to sleep. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_uidle(void) 
.................... { 
....................    debug_usb(debug_putc, "I"); 
....................  
....................    UIE_ACTV = 1;   //enable activity interrupt flag. (we are now suspended until we get an activity interrupt. nice) 
*
0853:  BSF    12.2
....................  
....................    //UIR_IDLE = 0; //clear idle interrupt flag 
....................    UIR &= ~(1 << BIT_IDLE); 
0854:  BCF    10.4
....................  
....................    UCON_SUSPND = 1; //set suspend. we are now suspended 
0855:  BSF    0E.1
.................... } 
....................  
....................  
.................... /****************************************************************************** 
.................... /* usb_isr_activity() 
.................... /* 
.................... /* Summary: USB peripheral detected activity on the USB device.  Wake-up the USB 
.................... /*          peripheral. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_activity(void) 
.................... { 
....................    debug_usb(debug_putc, "A"); 
....................  
....................    UCON_SUSPND = 0; //turn off low power suspending 
*
080C:  BCF    0E.1
....................    UIE_ACTV = 0; //clear activity interupt enabling 
080D:  BCF    12.2
....................  
....................    while(UIR_ACTV) 
080E:  BTFSS  10.2
080F:  GOTO   012
....................    { 
....................       //UIR_ACTV = 0; 
....................       UIR &= ~(1 << BIT_ACTV); 
0810:  BCF    10.2
0811:  GOTO   00E
....................    } 
.................... } 
....................  
.................... /****************************************************************************** 
.................... /* usb_isr_stall() 
.................... /* 
.................... /* Summary: Stall handshake detected. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_stall(void) 
.................... { 
....................    debug_usb(debug_putc, "S"); 
....................  
....................  
....................    if (bit_test(UEP(0),0)) 
*
081B:  BTFSS  18.0
081C:  GOTO   023
....................    { 
....................       usb_init_ep0_setup(); 
081D:  MOVLP  00
081E:  MOVLB  00
081F:  CALL   183
0820:  MOVLP  08
....................       bit_clear(UEP(0), 0); 
0821:  MOVLB  1D
0822:  BCF    18.0
....................    } 
....................  
....................    //UIR_STALL = 0; 
....................    UIR &= ~(1 << BIT_STALL); 
0823:  BCF    10.5
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_request_send_response(unsigned int8 len) {__setup_0_tx_size = len;} 
*
0241:  MOVLB  04
0242:  MOVF   64,W
0243:  MOVWF  73
0244:  MOVLB  00
0245:  RETURN
.................... void usb_request_get_data(void)  {__setup_0_tx_size = 0xFE;} 
*
02AC:  MOVLW  FE
02AD:  MOVWF  73
02AE:  RETURN
.................... void usb_request_stall(void)  {__setup_0_tx_size = 0xFF;} 
*
0246:  MOVLW  FF
0247:  MOVWF  73
0248:  RETURN
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_tok_dne() 
.................... /* 
.................... /* Summary: A Token (IN/OUT/SETUP) has been received by the USB peripheral. 
.................... /*          If a setup token on EP0 was received, run the chapter 9 code and 
.................... /*          handle the request. 
.................... /*          If an IN token on EP0 was received, continue transmitting any 
.................... /*          unfinished requests that may take more than one packet to transmit 
.................... /*          (if necessary). 
.................... /*          If an OUT token on any other EP was received, mark that EP as ready 
.................... /*          for a usb_get_packet(). 
.................... /*          Does not handle any IN or OUT tokens on EP0. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_tok_dne(void) 
.................... { 
....................    unsigned int8 en; 
....................  
....................    en = USTATCopy>>3; 
*
0864:  RRF    71,W
0865:  MOVLB  04
0866:  MOVWF  5E
0867:  RRF    5E,F
0868:  RRF    5E,F
0869:  MOVLW  1F
086A:  ANDWF  5E,F
....................  
....................    debug_usb(debug_putc, "T "); 
....................    debug_usb(debug_putc, "%X ", USTATCopy); 
....................  
....................    if (USTATCopy == USTAT_OUT_SETUP_E0) 
086B:  MOVF   71,F
086C:  BTFSS  03.2
086D:  GOTO   439
....................    { 
....................       //new out or setup token in the buffer 
....................       int8 pidKey; 
....................  
....................       debug_usb(debug_putc,"%X ", EP_BDxST_O(0)); 
....................  
....................       pidKey = EP_BDxST_O(0) & 0x3C;  //save PID 
086E:  MOVLB  00
086F:  MOVF   20,W
0870:  ANDLW  3C
0871:  MOVLB  04
0872:  MOVWF  5F
....................  
....................       EP_BDxST_O(0) &= 0x43;  //clear pid, prevent bdstal/pid confusion 
0873:  MOVLW  43
0874:  MOVLB  00
0875:  ANDWF  20,F
....................  
....................       if (pidKey == USB_PIC_PID_SETUP) 
0876:  MOVLB  04
0877:  MOVF   5F,W
0878:  SUBLW  34
0879:  BTFSS  03.2
087A:  GOTO   414
....................       { 
....................          if ((EP_BDxST_I(0) & 0x80) != 0x00) 
087B:  MOVLB  00
087C:  MOVF   24,W
087D:  ANDLW  80
087E:  BTFSS  03.2
....................             EP_BDxST_I(0)=0;   // return the in buffer to us (dequeue any pending requests) 
087F:  CLRF   24
....................  
....................          debug_usb(debug_putc,"(%U) ", EP_BDxCNT_O(0)); 
....................          debug_display_ram(EP_BDxCNT_O(0), usb_ep0_rx_buffer); 
....................  
....................          usb_isr_tok_setup_dne(); 
....................  
....................          UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit 
*
0BED:  MOVLB  1D
0BEE:  BCF    0E.4
....................  
....................          //if setup_0_tx_size==0xFF - stall ep0 (unhandled request) (see usb_request_stall()) 
....................          //if setup_0_tx_size==0xFE - get EP0OUT ready for a data packet, leave EP0IN alone (see usb_request_get_data()) 
....................          //else setup_0_tx_size=size of response, get EP0OUT ready for a setup packet, mark EPOIN ready for transmit (see usb_request_send_response()) 
....................          if (__setup_0_tx_size == 0xFF) 
0BEF:  INCFSZ 73,W
0BF0:  GOTO   3FB
....................             usb_flush_out(0, USB_DTS_STALL); 
0BF1:  MOVLB  04
0BF2:  CLRF   61
0BF3:  MOVLW  03
0BF4:  MOVWF  62
0BF5:  MOVLP  00
0BF6:  MOVLB  00
0BF7:  CALL   2AF
0BF8:  MOVLP  08
0BF9:  GOTO   412
0BFA:  MOVLB  1D
....................          else 
....................          { 
....................             usb_flush_out(0, USB_DTS_TOGGLE); 
0BFB:  MOVLB  04
0BFC:  CLRF   61
0BFD:  MOVLW  02
0BFE:  MOVWF  62
0BFF:  MOVLP  00
0C00:  MOVLB  00
0C01:  CALL   2AF
0C02:  MOVLP  08
....................             if (__setup_0_tx_size != 0xFE) 
0C03:  MOVF   73,W
0C04:  SUBLW  FE
0C05:  BTFSC  03.2
0C06:  GOTO   412
....................                usb_flush_in(0 ,__setup_0_tx_size, USB_DTS_USERX); 
0C07:  MOVLB  04
0C08:  CLRF   69
0C09:  CLRF   6B
0C0A:  MOVF   73,W
0C0B:  MOVWF  6A
0C0C:  MOVLW  04
0C0D:  MOVWF  6C
0C0E:  MOVLP  00
0C0F:  MOVLB  00
0C10:  CALL   32D
0C11:  MOVLP  08
....................          } 
....................          //why was this here? 
....................          //UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit 
....................       } 
0C12:  GOTO   437
0C13:  MOVLB  04
....................       else if (pidKey == USB_PIC_PID_OUT) 
0C14:  MOVF   5F,W
0C15:  SUBLW  04
0C16:  BTFSS  03.2
0C17:  GOTO   438
....................       { 
....................          usb_isr_tok_out_dne(0); 
0C18:  CLRF   60
0C19:  MOVLP  00
0C1A:  MOVLB  00
0C1B:  CALL   39C
0C1C:  MOVLP  08
....................          usb_flush_out(0, USB_DTS_TOGGLE); 
0C1D:  MOVLB  04
0C1E:  CLRF   61
0C1F:  MOVLW  02
0C20:  MOVWF  62
0C21:  MOVLP  00
0C22:  MOVLB  00
0C23:  CALL   2AF
0C24:  MOVLP  08
....................          if ((__setup_0_tx_size!=0xFE) && (__setup_0_tx_size!=0xFF)) 
0C25:  MOVF   73,W
0C26:  SUBLW  FE
0C27:  BTFSC  03.2
0C28:  GOTO   437
0C29:  INCFSZ 73,W
0C2A:  GOTO   42C
0C2B:  GOTO   437
....................          { 
....................             usb_flush_in(0,__setup_0_tx_size,USB_DTS_DATA1);   //send response (usually a 0len) 
0C2C:  MOVLB  04
0C2D:  CLRF   69
0C2E:  CLRF   6B
0C2F:  MOVF   73,W
0C30:  MOVWF  6A
0C31:  MOVLW  01
0C32:  MOVWF  6C
0C33:  MOVLP  00
0C34:  MOVLB  00
0C35:  CALL   32D
0C36:  MOVLP  08
....................          } 
....................       } 
0C37:  MOVLB  04
....................       else 
....................       { 
....................          debug_usb(debug_putc, "!!! "); 
....................       } 
....................    } 
0C38:  GOTO   465
....................    else if (USTATCopy == USTAT_IN_E0) 
0C39:  MOVF   71,W
0C3A:  SUBLW  04
0C3B:  BTFSS  03.2
0C3C:  GOTO   454
....................    { 
....................       //pic -> host transfer completed 
....................       //EP_BDxST_I(0) = EP_BDxST_I(0) & 0xC3;   //clear up any BDSTAL confusion 
....................       __setup_0_tx_size = 0xFF; 
0C3D:  MOVLW  FF
0C3E:  MOVWF  73
....................       usb_isr_tok_in_dne(0); 
0C3F:  CLRF   60
0C40:  MOVLP  00
0C41:  MOVLB  00
0C42:  CALL   44F
0C43:  MOVLP  08
....................       if (__setup_0_tx_size!=0xFF) 
0C44:  INCFSZ 73,W
0C45:  GOTO   447
0C46:  GOTO   452
....................          usb_flush_in(0, __setup_0_tx_size, USB_DTS_TOGGLE); 
0C47:  MOVLB  04
0C48:  CLRF   69
0C49:  CLRF   6B
0C4A:  MOVF   73,W
0C4B:  MOVWF  6A
0C4C:  MOVLW  02
0C4D:  MOVWF  6C
0C4E:  MOVLP  00
0C4F:  MOVLB  00
0C50:  CALL   32D
0C51:  MOVLP  08
....................       else 
....................       { 
....................          //usb_init_ep0_setup(); //REMOVED JUN/9/2009 
....................       } 
....................    } 
0C52:  GOTO   464
0C53:  MOVLB  04
....................    else 
....................    { 
....................       if (!bit_test(USTATCopy, 2)) 
0C54:  BTFSC  71.2
0C55:  GOTO   45E
....................       { 
....................          //EP_BDxST_O(en) = EP_BDxST_O(en) & 0xC3;   //clear up any BDSTAL confusion 
....................          usb_isr_tok_out_dne(en); 
0C56:  MOVF   5E,W
0C57:  MOVWF  60
0C58:  MOVLP  00
0C59:  MOVLB  00
0C5A:  CALL   39C
0C5B:  MOVLP  08
....................       } 
0C5C:  GOTO   464
0C5D:  MOVLB  04
....................       else 
....................       { 
....................          //EP_BDxST_I(en) = EP_BDxST_I(en) & 0xC3;   //clear up any BDSTAL confusion 
....................          usb_isr_tok_in_dne(en); 
0C5E:  MOVF   5E,W
0C5F:  MOVWF  60
0C60:  MOVLP  00
0C61:  MOVLB  00
0C62:  CALL   44F
0C63:  MOVLP  08
0C64:  MOVLB  04
....................       } 
....................    } 
.................... } 
....................  
.................... /// END USB Interrupt Service Routine 
....................  
.................... #ENDIF 
....................  
.................... #endif 
....................  
.................... #if defined(__PIC18_USB_H__) 
....................  #include <pic18_usb.c> 
.................... #endif 
....................  
.................... #if defined(__PIC24_USB_H__) 
....................  #include <pic24_usb.c> 
.................... #endif 
....................  
.................... #if defined(__USBN960X_H__) 
....................  #include <usbn960x.c> 
.................... #endif 
....................  
....................  
.................... #IFNDEF __USB_HARDWARE__ 
....................    #ERROR You must include USB hardware driver. 
.................... #ENDIF 
....................  
.................... #IFNDEF __USB_DESCRIPTORS__ 
....................    #ERROR You must include USB descriptors. 
.................... #ENDIF 
....................  
.................... #if (defined(USB_USE_FULL_SPEED) && (USB_USE_FULL_SPEED==1)) 
....................    #define USB_ISO_PACKET_MAX_SIZE     1023 
....................    #define USB_NONISO_PACKET_MAX_SIZE  64 
.................... #else 
....................    #define USB_ISO_PACKET_MAX_SIZE     1023 
....................    #define USB_NONISO_PACKET_MAX_SIZE  8 
.................... #endif 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #if USB_EP1_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP1_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP1_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP1_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP1_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP1_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP1_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP1_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP1_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #if USB_EP2_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP2_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP2_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP2_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP2_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP2_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP2_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP2_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP2_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #if USB_EP3_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP3_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP3_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP3_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP3_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP3_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP3_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP3_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP3_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #if USB_EP4_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP4_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP4_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP4_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP4_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP4_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP4_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP4_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP4_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #if USB_EP5_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP5_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP5_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP5_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP5_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP5_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP5_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP5_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP5_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #if USB_EP6_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP6_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP6_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP6_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP6_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP6_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP6_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP6_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP6_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #if USB_EP7_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP7_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP7_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP7_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP7_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP7_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP7_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP7_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP7_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #if USB_EP8_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP8_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP8_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP8_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP8_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP8_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP8_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP8_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP8_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #if USB_EP9_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP9_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP9_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP9_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP9_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP9_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP9_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP9_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP9_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #if USB_EP10_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP10_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP10_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP10_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP10_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP11_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP11_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP11_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP11_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #if USB_EP11_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP11_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP11_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP11_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP11_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP11_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP11_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP11_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP11_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif    
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #if USB_EP12_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP12_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP12_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP12_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP12_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif    
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP12_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP12_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP12_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP12_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif    
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #if USB_EP13_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP13_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP13_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP13_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP13_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif    
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP13_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP13_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP13_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP13_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #if USB_EP14_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP14_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP14_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP14_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP14_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP14_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP14_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP14_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP14_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #if USB_EP15_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP15_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP15_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP15_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP15_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP15_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP15_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP15_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP15_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif    
.................... #endif 
....................  
.................... TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... unsigned int8 USB_address_pending;                        //save previous state because packets can take several isrs 
.................... unsigned int16 usb_getdesc_ptr; unsigned int16 usb_getdesc_len;             //for reading string and config descriptors 
....................  
.................... #IF USB_HID_BOOT_PROTOCOL 
.................... unsigned int8 hid_protocol[USB_NUM_HID_INTERFACES]; 
.................... #ENDIF 
....................  
.................... void usb_match_registers(int8 endpoint, int16 *status, int16 *buffer, int8 *size); 
....................  
.................... void usb_isr_tkn_setup_StandardEndpoint(void); 
.................... void usb_isr_tkn_setup_StandardDevice(void); 
.................... void usb_isr_tkn_setup_StandardInterface(void); 
.................... #IF USB_HID_DEVICE 
....................    void usb_isr_tkn_setup_ClassInterface(void); 
.................... #ENDIF 
.................... void usb_Get_Descriptor(void); 
.................... void usb_copy_desc_seg_to_ep(void); 
.................... void usb_finish_set_address(void); 
....................  
.................... int8 USB_Interface[USB_MAX_NUM_INTERFACES];              //config state for all of our interfaces, NUM_INTERFACES defined with descriptors 
....................  
.................... /// BEGIN User Functions 
....................  
.................... // see usb.h for documentation 
.................... int1 usb_enumerated(void) 
.................... { 
....................    return(USB_stack_status.curr_config); 
.................... } 
....................  
.................... // see usb.h for documentation 
.................... void usb_wait_for_enumeration(void)  
.................... { 
....................    while (USB_stack_status.curr_config == 0) {restart_wdt();} 
.................... } 
....................  
.................... // see USB.H for documentation 
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout) { 
....................    unsigned int16 i=0; 
....................    int1 res; 
....................    unsigned int16 this_packet_len; 
....................    unsigned int16 packet_size; 
....................    unsigned int32 timeout_1us; 
....................  
....................    packet_size = usb_ep_tx_size[endpoint]; 
....................     
....................    //printf("\r\nUSB PUTS %U LEN=%LU MAX_PACK=%LU\r\n", endpoint, len, packet_size); 
....................  
....................    //send data packets until timeout or no more packets to send 
....................    while (i < len)  
....................    { 
....................       timeout_1us = (int32)timeout*1000; 
....................       if ((len - i) > packet_size) {this_packet_len = packet_size;} 
....................       else {this_packet_len = len-i;} 
....................       //putc('*'); 
....................       do  
....................       { 
....................          res = usb_put_packet(endpoint, ptr + i, this_packet_len, USB_DTS_TOGGLE);   //send 64 byte packets 
....................          //putc('.'); 
....................          if (!res) 
....................          { 
....................             delay_us(1); 
....................             //delay_ms(500); 
....................             timeout_1us--; 
....................          } 
....................       } while (!res && (!timeout || timeout_1us)); 
....................       i += packet_size; 
....................    } 
....................  
....................  
....................    //send 0len packet if needed 
....................    if (i==len) { 
....................       timeout_1us=(int32)timeout*1000; 
....................       do { 
....................          res = usb_put_packet(endpoint,0,0,USB_DTS_TOGGLE);   //indicate end of message 
....................          if (!res) { 
....................             delay_us(1); 
....................             timeout_1us--; 
....................          } 
....................       } while (!res && (!timeout || timeout_1us)); 
....................    } 
....................  
....................    return(res); 
.................... } 
....................  
.................... // see usb.h for documentation 
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout) { 
....................    unsigned int16 ret=0; 
....................    unsigned int16 to; 
....................    unsigned int16 len; 
....................    unsigned int16 packet_size; 
....................    unsigned int16 this_packet_max; 
....................  
....................    packet_size=usb_ep_rx_size[endpoint]; 
....................  
....................    do { 
....................       if (packet_size < max) {this_packet_max=packet_size;} else {this_packet_max=max;} 
....................       to=0; 
....................       do { 
....................          len = packet_size; 
....................          if (usb_kbhit(endpoint)) { 
....................             len=usb_get_packet(endpoint,ptr,this_packet_max); 
....................             ptr+=len; 
....................             max-=len; 
....................             ret+=len; 
....................             break; 
....................          } 
....................          else { 
....................             to++; 
....................             delay_ms(1); 
....................          } 
....................       } while (to!=timeout); 
....................    } while ((len == packet_size) && (!timeout || (to!=timeout)) && max); 
....................  
....................    return(ret); 
.................... } 
....................  
.................... /// END User Functions 
....................  
....................  
.................... /// BEGIN USB Token, standard and HID request handler (part of ISR) 
....................  
.................... // see usb.h for documentation 
.................... void usb_token_reset(void)  
.................... { 
....................    unsigned int i; 
....................  
....................    usb_getdesc_len = 0; 
*
0221:  MOVLB  02
0222:  CLRF   46
0223:  CLRF   45
....................     
....................    for (i=0;i<USB_MAX_NUM_INTERFACES;i++)  
0224:  MOVLB  04
0225:  CLRF   5E
0226:  MOVF   5E,W
0227:  SUBLW  01
0228:  BTFSS  03.0
0229:  GOTO   234
....................       USB_Interface[i] = 0;   //reset each interface to default 
022A:  MOVLW  C7
022B:  ADDWF  5E,W
022C:  MOVWF  04
022D:  MOVLW  20
022E:  MOVWF  05
022F:  BTFSC  03.0
0230:  INCF   05,F
0231:  CLRF   00
....................  
....................   #IF USB_HID_BOOT_PROTOCOL 
....................    for (i=0;i<USB_NUM_HID_INTERFACES; i++) 
....................       hid_protocol[i] = 1; 
....................   #endif 
....................  
....................   #if USB_CDC_DEVICE 
0232:  INCF   5E,F
0233:  GOTO   226
....................    usb_cdc_init(); 
0234:  MOVLB  00
0235:  CALL   1F8
....................   #endif 
....................  
....................    USB_stack_status.curr_config = 0;      //unconfigured device 
0236:  MOVLB  02
0237:  CLRF   3D
....................  
....................    USB_stack_status.status_device = 1;    //previous state.  init at none 
0238:  MOVLW  01
0239:  MOVWF  3E
....................    USB_stack_status.dev_req = NONE;       //previous token request state.  init at none 
023A:  CLRF   3C
023B:  MOVLB  00
023C:  RETURN
.................... } 
....................  
.................... //send a 0len packet to endpoint 0 (optimization) 
.................... //notice that this doesnt return the status 
.................... #define usb_put_0len_0() usb_request_send_response(0) 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
*
0198:  MOVLB  04
0199:  BCF    6B.0
019A:  BTFSC  6A.7
019B:  BSF    6B.0
....................     
....................    endpoint &= 0x7F; 
019C:  BCF    6A.7
....................     
....................    if (endpoint > 16) 
019D:  MOVF   6A,W
019E:  SUBLW  10
019F:  BTFSC  03.0
01A0:  GOTO   1A4
....................       return(FALSE); 
01A1:  MOVLW  00
01A2:  MOVWF  78
01A3:  GOTO   1BE
....................     
....................    if (direction) { //IN 
01A4:  BTFSS  6B.0
01A5:  GOTO   1B3
....................       return(usb_ep_tx_type[endpoint] != USB_ENABLE_DISABLED); 
01A6:  MOVF   6A,W
01A7:  MOVLB  00
01A8:  CALL   07C
01A9:  SUBLW  FF
01AA:  BTFSS  03.2
01AB:  GOTO   1AE
01AC:  MOVLW  00
01AD:  GOTO   1AF
01AE:  MOVLW  01
01AF:  MOVWF  78
01B0:  MOVLB  04
01B1:  GOTO   1BE
....................    } 
01B2:  GOTO   1BE
....................    else {   //OUT 
....................       return(usb_ep_rx_type[endpoint] != USB_ENABLE_DISABLED); 
01B3:  MOVF   6A,W
01B4:  MOVLB  00
01B5:  CALL   08D
01B6:  SUBLW  FF
01B7:  BTFSS  03.2
01B8:  GOTO   1BB
01B9:  MOVLW  00
01BA:  GOTO   1BC
01BB:  MOVLW  01
01BC:  MOVWF  78
01BD:  MOVLB  04
....................    } 
01BE:  MOVLB  00
01BF:  RETURN
.................... } 
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint) { 
....................    if (endpoint==0) { 
*
044F:  MOVLB  04
0450:  MOVF   60,F
0451:  BTFSS  03.2
0452:  GOTO   473
....................       if (USB_stack_status.dev_req == GET_DESCRIPTOR) {usb_copy_desc_seg_to_ep();} //check this, we are missing report descriptor? 
0453:  MOVLB  02
0454:  DECFSZ 3C,W
0455:  GOTO   45A
0456:  MOVLB  00
0457:  CALL   249
0458:  GOTO   471
0459:  MOVLB  02
....................       else if (USB_stack_status.dev_req == SET_ADDRESS) {usb_finish_set_address();} 
045A:  MOVF   3C,W
045B:  SUBLW  02
045C:  BTFSS  03.2
045D:  GOTO   470
....................    } 
....................   #if USB_CDC_DEVICE 
*
0471:  GOTO   479
0472:  MOVLB  04
....................   else if (endpoint==USB_CDC_DATA_IN_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
0473:  MOVF   60,W
0474:  SUBLW  02
0475:  BTFSS  03.2
0476:  GOTO   47A
....................       usb_isr_tok_in_cdc_data_dne(); 
....................   } 
....................   #endif 
*
047A:  MOVLB  00
047B:  RETURN
.................... } 
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint) 
.................... { 
....................    //TODO: 
....................    if (endpoint==0) { 
*
039C:  MOVLB  04
039D:  MOVF   60,F
039E:  BTFSS  03.2
039F:  GOTO   3DC
....................      debug_usb(debug_putc,"TOUT 0 "); 
....................      #if USB_CDC_DEVICE 
....................       usb_isr_tok_out_cdc_control_dne(); 
....................      //#else   //REMOVED JUN/9/2009 
....................      //usb_init_ep0_setup(); 
....................      #endif 
....................    } 
....................   #if USB_CDC_DEVICE 
*
03DA:  GOTO   3FE
03DB:  MOVLB  04
....................    else if (endpoint==USB_CDC_DATA_OUT_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
03DC:  MOVF   60,W
03DD:  SUBLW  02
03DE:  BTFSS  03.2
03DF:  GOTO   400
....................       usb_isr_tok_out_cdc_data_dne(); 
....................    } 
....................   #endif 
*
0400:  MOVLB  00
0401:  RETURN
....................    //else { 
....................    //   bit_set(__usb_kbhit_status,endpoint); 
....................    //} 
.................... } 
....................  
....................  
.................... //---- process setup message stage -----------// 
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_setup_dne(void)  
.................... { 
....................    USB_stack_status.dev_req=NONE; // clear the device request.. 
*
0880:  MOVLB  02
0881:  CLRF   3C
....................  
....................    switch(usb_ep0_rx_buffer[0] & 0x7F) { 
0882:  MOVLB  00
0883:  MOVF   38,W
0884:  ANDLW  7F
0885:  BTFSC  03.2
0886:  GOTO   091
0887:  XORLW  01
0888:  BTFSC  03.2
0889:  GOTO   271
088A:  XORLW  03
088B:  BTFSC  03.2
088C:  GOTO   2D0
088D:  XORLW  23
088E:  BTFSC  03.2
088F:  GOTO   375
0890:  GOTO   3EA
....................  
....................       case 0x00:  //standard to device 
....................          debug_usb_token(debug_putc," d"); 
....................          usb_isr_tkn_setup_StandardDevice(); 
....................          break; 
*
0A70:  GOTO   3ED
....................  
....................       case 0x01:  //standard to interface 
....................          debug_usb_token(debug_putc," i"); 
....................          usb_isr_tkn_setup_StandardInterface(); 
....................          break; 
*
0ACF:  GOTO   3ED
....................  
....................       case 0x02:  //standard to endpoint 
....................          debug_usb_token(debug_putc," e"); 
....................          usb_isr_tkn_setup_StandardEndpoint(); 
....................          break; 
*
0B74:  GOTO   3ED
....................           
.................... #IF USB_HID_DEVICE || USB_CDC_DEVICE 
....................       case 0x21:  //class specific request.  the only class this driver supports is HID 
....................          debug_usb_token(debug_putc, " class"); 
....................         #if USB_HID_DEVICE && USB_CDC_DEVICE 
....................          if (usb_ep0_rx_buffer[4] == USB_HID_INTERFACE) 
....................          { 
....................             usb_isr_tkn_setup_ClassInterface(); 
....................          } 
....................          else 
....................          { 
....................             usb_isr_tkn_cdc(); 
....................          } 
....................         #elif USB_HID_DEVICE 
....................          usb_isr_tkn_setup_ClassInterface(); 
....................         #else 
....................          usb_isr_tkn_cdc(); 
....................         #endif 
....................          break; 
*
0BE9:  GOTO   3ED
.................... #endif 
....................  
....................  
....................       //TODO: IF YOU WANT VENDOR SPECIFC REQUEST SUPPORT YOU MUST ADD IT HERE 
....................  
....................       default: 
....................          usb_request_stall(); 
0BEA:  MOVLP  00
0BEB:  CALL   246
0BEC:  MOVLP  08
....................          break; 
....................    } 
.................... } 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardDevice() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Device request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardDevice(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
*
0891:  MOVF   39,W
0892:  BTFSC  03.2
0893:  GOTO   0A7
0894:  XORLW  01
0895:  BTFSC  03.2
0896:  GOTO   0B4
0897:  XORLW  02
0898:  BTFSC  03.2
0899:  GOTO   0C4
089A:  XORLW  06
089B:  BTFSC  03.2
089C:  GOTO   0D3
089D:  XORLW  03
089E:  BTFSC  03.2
089F:  GOTO   0E0
08A0:  XORLW  0E
08A1:  BTFSC  03.2
08A2:  GOTO   174
08A3:  XORLW  01
08A4:  BTFSC  03.2
08A5:  GOTO   180
08A6:  GOTO   26D
....................  
....................       case USB_STANDARD_REQUEST_GET_STATUS:  //0 
....................             debug_usb_token(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.status_device; 
08A7:  MOVLB  02
08A8:  MOVF   3E,W
08A9:  MOVLB  00
08AA:  MOVWF  40
....................             usb_ep0_tx_buffer[1]=0; 
08AB:  CLRF   41
....................             usb_request_send_response(2); 
08AC:  MOVLW  02
08AD:  MOVLB  04
08AE:  MOVWF  64
08AF:  MOVLP  00
08B0:  MOVLB  00
08B1:  CALL   241
08B2:  MOVLP  08
....................             break; 
08B3:  GOTO   270
....................  
....................       case USB_STANDARD_REQUEST_CLEAR_FEATURE:  //1 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
08B4:  DECFSZ 3A,W
08B5:  GOTO   0C0
....................                debug_usb_token(debug_putc,"CF"); 
....................                USB_stack_status.status_device &= 1; 
08B6:  MOVLW  01
08B7:  MOVLB  02
08B8:  ANDWF  3E,F
....................                usb_put_0len_0(); 
08B9:  MOVLB  04
08BA:  CLRF   64
08BB:  MOVLP  00
08BC:  MOVLB  00
08BD:  CALL   241
08BE:  MOVLP  08
....................             } 
08BF:  GOTO   0C3
....................             else 
....................                usb_request_stall(); 
08C0:  MOVLP  00
08C1:  CALL   246
08C2:  MOVLP  08
....................             break; 
08C3:  GOTO   270
....................  
....................       case USB_STANDARD_REQUEST_SET_FEATURE: //3 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
08C4:  DECFSZ 3A,W
08C5:  GOTO   0CF
....................                debug_usb_token(debug_putc,"SF"); 
....................                USB_stack_status.status_device |= 2; 
08C6:  MOVLB  02
08C7:  BSF    3E.1
....................                usb_put_0len_0(); 
08C8:  MOVLB  04
08C9:  CLRF   64
08CA:  MOVLP  00
08CB:  MOVLB  00
08CC:  CALL   241
08CD:  MOVLP  08
....................             } 
08CE:  GOTO   0D2
....................             else 
....................                usb_request_stall(); 
08CF:  MOVLP  00
08D0:  CALL   246
08D1:  MOVLP  08
....................             break; 
08D2:  GOTO   270
....................  
....................       case USB_STANDARD_REQUEST_SET_ADDRESS: //5 
....................             debug_usb_token(debug_putc,"SA"); 
....................             USB_stack_status.dev_req=SET_ADDRESS; //currently processing set_address request 
08D3:  MOVLW  02
08D4:  MOVLB  02
08D5:  MOVWF  3C
....................             USB_address_pending=usb_ep0_rx_buffer[2]; 
08D6:  MOVLB  00
08D7:  MOVF   3A,W
08D8:  MOVWF  74
....................             #ifdef __USBN__   //NATIONAL part handles this differently than pic16c7x5 
....................             USB_stack_status.dev_req=NONE; //currently processing set_address request 
....................             usb_set_address(USB_address_pending); 
....................             USB_stack_status.curr_config=0;   // make sure current configuration is 0 
....................             #endif 
....................             usb_put_0len_0(); 
08D9:  MOVLB  04
08DA:  CLRF   64
08DB:  MOVLP  00
08DC:  MOVLB  00
08DD:  CALL   241
08DE:  MOVLP  08
....................             break; 
08DF:  GOTO   270
....................  
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: //6 
....................             debug_usb_token(debug_putc,"GD"); 
....................             usb_Get_Descriptor(); 
....................             break; 
*
0973:  GOTO   270
....................  
....................       case USB_STANDARD_REQUEST_GET_CONFIGURATION: //8 
....................             debug_usb_token(debug_putc,"GC"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.curr_config; 
0974:  MOVLB  02
0975:  MOVF   3D,W
0976:  MOVLB  00
0977:  MOVWF  40
....................             usb_request_send_response(1); 
0978:  MOVLW  01
0979:  MOVLB  04
097A:  MOVWF  64
097B:  MOVLP  00
097C:  MOVLB  00
097D:  CALL   241
097E:  MOVLP  08
....................             break; 
097F:  GOTO   270
....................  
....................       case USB_STANDARD_REQUEST_SET_CONFIGURATION: //9 
....................             if (usb_ep0_rx_buffer[2] <= USB_NUM_CONFIGURATIONS) { 
0980:  MOVF   3A,W
0981:  SUBLW  01
0982:  BTFSS  03.0
0983:  GOTO   26C
....................                USB_stack_status.curr_config=usb_ep0_rx_buffer[2]; 
0984:  MOVF   3A,W
0985:  MOVLB  02
0986:  MOVWF  3D
....................                usb_set_configured(usb_ep0_rx_buffer[2]); 
0987:  MOVLB  00
0988:  MOVF   3A,W
0989:  MOVLB  04
098A:  MOVWF  60
....................                debug_usb_token(debug_putc,"SC%U", USB_stack_status.curr_config);                
....................                usb_put_0len_0(); 
*
0A66:  MOVLB  04
0A67:  CLRF   64
0A68:  MOVLP  00
0A69:  MOVLB  00
0A6A:  CALL   241
0A6B:  MOVLP  08
....................             } 
....................             break; 
0A6C:  GOTO   270
....................  
....................       default: 
....................             usb_request_stall(); 
0A6D:  MOVLP  00
0A6E:  CALL   246
0A6F:  MOVLP  08
....................             break; 
....................    } 
.................... } 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Interface request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardInterface(void) { 
....................    unsigned int8 curr_config; 
....................  
....................    curr_config=USB_stack_status.curr_config; 
*
0A71:  MOVLB  02
0A72:  MOVF   3D,W
0A73:  MOVLB  04
0A74:  MOVWF  60
....................  
....................    switch (usb_ep0_rx_buffer[1]) { 
0A75:  MOVLB  00
0A76:  MOVF   39,W
0A77:  BTFSC  03.2
0A78:  GOTO   280
0A79:  XORLW  0A
0A7A:  BTFSC  03.2
0A7B:  GOTO   28A
0A7C:  XORLW  01
0A7D:  BTFSC  03.2
0A7E:  GOTO   2B1
0A7F:  GOTO   2CC
....................       case USB_STANDARD_REQUEST_GET_STATUS: 
....................             debug_usb_token(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=0; 
0A80:  CLRF   40
....................             usb_ep0_tx_buffer[1]=0; 
0A81:  CLRF   41
....................             usb_request_send_response(2); 
0A82:  MOVLW  02
0A83:  MOVLB  04
0A84:  MOVWF  64
0A85:  MOVLP  00
0A86:  MOVLB  00
0A87:  CALL   241
0A88:  MOVLP  08
....................             break; 
0A89:  GOTO   2CF
....................  
....................       case USB_STANDARD_REQUEST_GET_INTERFACE: 
....................             if ( curr_config && (usb_ep0_rx_buffer[4] < USB_NUM_INTERFACES[curr_config-1]) ) {   //book says only supports configed state 
0A8A:  MOVLB  04
0A8B:  MOVF   60,F
0A8C:  BTFSC  03.2
0A8D:  GOTO   2AC
0A8E:  MOVLW  01
0A8F:  SUBWF  60,W
0A90:  MOVLP  00
0A91:  MOVLB  00
0A92:  CALL   124
0A93:  MOVLP  08
0A94:  MOVWF  78
0A95:  SUBWF  3C,W
0A96:  BTFSS  03.0
0A97:  GOTO   29A
0A98:  MOVLB  04
0A99:  GOTO   2AC
....................                debug_usb_token(debug_putc,"GI"); 
....................                usb_ep0_tx_buffer[0]=USB_Interface[usb_ep0_rx_buffer[4]];//our new outgoing byte 
0A9A:  MOVLW  C7
0A9B:  ADDWF  3C,W
0A9C:  MOVWF  04
0A9D:  MOVLW  20
0A9E:  MOVWF  05
0A9F:  BTFSC  03.0
0AA0:  INCF   05,F
0AA1:  MOVF   00,W
0AA2:  MOVWF  40
....................                usb_request_send_response(1); //send byte back 
0AA3:  MOVLW  01
0AA4:  MOVLB  04
0AA5:  MOVWF  64
0AA6:  MOVLP  00
0AA7:  MOVLB  00
0AA8:  CALL   241
0AA9:  MOVLP  08
....................             } 
0AAA:  GOTO   2B0
0AAB:  MOVLB  04
....................             else 
....................                usb_request_stall(); 
0AAC:  MOVLP  00
0AAD:  MOVLB  00
0AAE:  CALL   246
0AAF:  MOVLP  08
....................             break; 
0AB0:  GOTO   2CF
....................  
....................       case USB_STANDARD_REQUEST_SET_INTERFACE: 
....................             if (curr_config) { //if configured state 
0AB1:  MOVLB  04
0AB2:  MOVF   60,F
0AB3:  BTFSC  03.2
0AB4:  GOTO   2C7
....................                debug_usb_token(debug_putc,"SI"); 
....................                USB_Interface[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
0AB5:  MOVLW  C7
0AB6:  MOVLB  00
0AB7:  ADDWF  3C,W
0AB8:  MOVWF  04
0AB9:  MOVLW  20
0ABA:  MOVWF  05
0ABB:  BTFSC  03.0
0ABC:  INCF   05,F
0ABD:  MOVF   3A,W
0ABE:  MOVWF  00
....................                usb_put_0len_0(); 
0ABF:  MOVLB  04
0AC0:  CLRF   64
0AC1:  MOVLP  00
0AC2:  MOVLB  00
0AC3:  CALL   241
0AC4:  MOVLP  08
....................             } 
0AC5:  GOTO   2CB
0AC6:  MOVLB  04
....................             else 
....................                usb_request_stall(); 
0AC7:  MOVLP  00
0AC8:  MOVLB  00
0AC9:  CALL   246
0ACA:  MOVLP  08
....................             break; 
0ACB:  GOTO   2CF
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: 
....................             debug_usb_token(debug_putc,"GDh"); 
....................             usb_Get_Descriptor(); 
....................             break; 
.................... #endif 
....................  
.................... //      case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
.................... //      case USB_STANDARD_REQUEST_SET_FEATURE: 
.................... //                let default take care of these, goto wrongstate 
....................       default: 
....................             usb_request_stall(); 
0ACC:  MOVLP  00
0ACD:  CALL   246
0ACE:  MOVLP  08
....................             break; 
....................    } 
.................... } 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardEndpoint() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Endpoint request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardEndpoint(void) { 
....................    if (usb_endpoint_is_valid(usb_ep0_rx_buffer[4])) { 
*
0AD0:  MOVF   3C,W
0AD1:  MOVLB  04
0AD2:  MOVWF  6A
0AD3:  MOVLP  00
0AD4:  MOVLB  00
0AD5:  CALL   198
0AD6:  MOVLP  08
0AD7:  MOVF   78,F
0AD8:  BTFSC  03.2
0AD9:  GOTO   374
....................       switch(usb_ep0_rx_buffer[1]) { 
0ADA:  MOVF   39,W
0ADB:  XORLW  01
0ADC:  BTFSC  03.2
0ADD:  GOTO   2E5
0ADE:  XORLW  02
0ADF:  BTFSC  03.2
0AE0:  GOTO   30D
0AE1:  XORLW  03
0AE2:  BTFSC  03.2
0AE3:  GOTO   336
0AE4:  GOTO   371
....................  
....................          case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
....................                debug_usb_token(debug_putc,"CF"); 
....................                usb_unstall_ep(usb_ep0_rx_buffer[4]); 
0AE5:  MOVF   3C,W
0AE6:  MOVLB  04
0AE7:  MOVWF  60
....................                usb_put_0len_0(); 
*
0B07:  CLRF   64
0B08:  MOVLP  00
0B09:  MOVLB  00
0B0A:  CALL   241
0B0B:  MOVLP  08
....................                break; 
0B0C:  GOTO   374
....................  
....................          case USB_STANDARD_REQUEST_SET_FEATURE: 
....................                      debug_usb_token(debug_putc,"SF"); 
....................                      usb_stall_ep(usb_ep0_rx_buffer[4]); 
0B0D:  MOVF   3C,W
0B0E:  MOVLB  04
0B0F:  MOVWF  60
....................                      usb_put_0len_0(); 
*
0B30:  CLRF   64
0B31:  MOVLP  00
0B32:  MOVLB  00
0B33:  CALL   241
0B34:  MOVLP  08
....................                      break; 
0B35:  GOTO   374
....................  
....................          case USB_STANDARD_REQUEST_GET_STATUS: 
....................                debug_usb_token(debug_putc,"GS"); 
....................                usb_ep0_tx_buffer[0]=0; 
0B36:  CLRF   40
....................                usb_ep0_tx_buffer[1]=0; 
0B37:  CLRF   41
....................                if (usb_endpoint_stalled(usb_ep0_rx_buffer[4])) { 
0B38:  MOVF   3C,W
0B39:  MOVLB  04
0B3A:  MOVWF  60
*
0B63:  MOVF   78,F
0B64:  BTFSC  03.2
0B65:  GOTO   36A
....................                   usb_ep0_tx_buffer[0]=1; 
0B66:  MOVLW  01
0B67:  MOVLB  00
0B68:  MOVWF  40
0B69:  MOVLB  04
....................                } 
....................                usb_request_send_response(2); 
0B6A:  MOVLW  02
0B6B:  MOVWF  64
0B6C:  MOVLP  00
0B6D:  MOVLB  00
0B6E:  CALL   241
0B6F:  MOVLP  08
....................                break; 
0B70:  GOTO   374
....................  
....................          default: 
....................             usb_request_stall(); 
0B71:  MOVLP  00
0B72:  CALL   246
0B73:  MOVLP  08
....................             break; 
....................       } 
....................    } 
.................... } 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_ClassInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Class request.  The only Class this drivers supports is HID. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /* Only compiled if HID_DEVICE is TRUE 
.................... /***************************************************************/ 
.................... #IF USB_HID_DEVICE 
.................... void usb_isr_tkn_setup_ClassInterface(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_GET_PROTOCOL:  //03 
....................             debug_usb_token(debug_putc,"GP"); 
....................             usb_ep0_tx_buffer[0]=hid_protocol[usb_ep0_rx_buffer[4]]; 
....................             usb_request_send_response(1); 
....................             break; 
....................     #ENDIF 
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_SET_PROTOCOL:  //0b 
....................             debug_usb_token(debug_putc,"SP"); 
....................             hid_protocol[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
....................             usb_put_0len_0(); //send 0len packet69 
....................             break; 
....................     #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_SET_IDLE:   //0a 
....................          #error TODO: if you want to support SET_IDLE, add code here 
....................    #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_GET_IDLE:   //02 
....................          #error TODO: if you want to support GET_IDLE, add code here 
....................    #ENDIF 
....................  
....................       default: 
....................             usb_request_stall(); 
....................             break; 
....................    } 
.................... } 
.................... #ENDIF 
....................  
.................... /************************************************************** 
.................... /* usb_Get_Descriptor() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[3] == wValue, which descriptor we want 
.................... /*        usb_ep0_rx_buffer[6,7] == Max length the host will accept 
.................... /* 
.................... /* Summary: Checks to see if we want a standard descriptor (Interface, Endpoint, Config, Device, String, etc.), 
.................... /*          or a class specific (HID) descriptor.  Since some pics (especially the PIC167x5) doesn't have 
.................... /*          pointers to constants we must simulate or own by setting up global registers that say 
.................... /*          which constant array to deal with, which position to start in this array, and the length. 
.................... /*          Once these globals are setup the first packet is sent.  If a descriptor takes more than one packet 
.................... /*          the PC will send an IN request to endpoint 0, and this will be handled by usb_isr_tok_in_dne() 
.................... /*          which will send the rest of the data. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_Get_Descriptor() { 
*
08E0:  MOVLB  04
08E1:  CLRF   60
....................    unsigned int8 i = 0; 
....................    usb_getdesc_ptr=0; 
08E2:  MOVLB  02
08E3:  CLRF   44
08E4:  CLRF   43
....................    USB_stack_status.getdesc_type=USB_GETDESC_CONFIG_TYPE; 
08E5:  CLRF   3F
....................  
....................    switch(usb_ep0_rx_buffer[3]) { 
08E6:  MOVLB  00
08E7:  MOVF   3B,W
08E8:  XORLW  01
08E9:  BTFSC  03.2
08EA:  GOTO   0F5
08EB:  XORLW  03
08EC:  BTFSC  03.2
08ED:  GOTO   0FC
08EE:  XORLW  01
08EF:  BTFSC  03.2
08F0:  GOTO   101
08F1:  XORLW  22
08F2:  BTFSC  03.2
08F3:  GOTO   12C
08F4:  GOTO   151
....................       case USB_DESC_DEVICE_TYPE:    //1 
....................             usb_getdesc_len=USB_DESC_DEVICE_LEN; 
08F5:  MOVLB  02
08F6:  CLRF   46
08F7:  MOVLW  12
08F8:  MOVWF  45
....................             USB_stack_status.getdesc_type=USB_GETDESC_DEVICE_TYPE; 
08F9:  MOVLW  03
08FA:  MOVWF  3F
....................             break; 
08FB:  GOTO   158
....................  
....................       //windows hosts will send a FF max len and expect you to send all configs without asking for them individually. 
....................       case USB_DESC_CONFIG_TYPE:   //2 
....................             usb_getdesc_len=USB_TOTAL_CONFIG_LEN; 
08FC:  MOVLB  02
08FD:  CLRF   46
08FE:  MOVLW  43
08FF:  MOVWF  45
....................             break; 
0900:  GOTO   158
....................  
....................       case USB_DESC_STRING_TYPE: //3 
....................             USB_stack_status.getdesc_type=USB_GETDESC_STRING_TYPE; 
0901:  MOVLW  02
0902:  MOVLB  02
0903:  MOVWF  3F
....................             //usb_getdesc_ptr=USB_STRING_DESC_OFFSET[usb_ep0_rx_buffer[2]]; 
....................             for(i=0; i<usb_ep0_rx_buffer[2]; i++) 
0904:  MOVLB  04
0905:  CLRF   60
0906:  MOVLB  00
0907:  MOVF   3A,W
0908:  MOVLB  04
0909:  SUBWF  60,W
090A:  BTFSC  03.0
090B:  GOTO   11C
....................             { 
....................                usb_getdesc_ptr += USB_STRING_DESC[usb_getdesc_ptr]; 
090C:  MOVLB  02
090D:  MOVF   44,W
090E:  MOVWF  7A
090F:  MOVF   43,W
0910:  MOVLP  00
0911:  MOVLB  00
0912:  CALL   04F
0913:  MOVLP  08
0914:  MOVWF  78
0915:  MOVLB  02
0916:  ADDWF  43,F
0917:  MOVLW  00
0918:  ADDWFC 44,F
0919:  MOVLB  04
091A:  INCF   60,F
091B:  GOTO   106
....................             } 
....................             usb_getdesc_len = USB_STRING_DESC[usb_getdesc_ptr]; 
091C:  MOVLB  02
091D:  MOVF   44,W
091E:  MOVWF  7A
091F:  MOVF   43,W
0920:  MOVLP  00
0921:  MOVLB  00
0922:  CALL   04F
0923:  MOVLP  08
0924:  MOVWF  78
0925:  CLRF   7A
0926:  MOVF   78,W
0927:  MOVLB  02
0928:  MOVWF  45
0929:  MOVF   7A,W
092A:  MOVWF  46
....................             break; 
092B:  GOTO   158
....................  
....................       //case USB_DESC_DEVICE_QUALIFIER_TYPE:   //0x06 
....................       // this is needed so host can find out about differences about this 
....................       // devices ability to handle full speed verses fast speed. 
....................       // since we don't support fast speed then we ignore this. 
....................       //      break; 
....................  
.................... #IF USB_HID_DEVICE || USB_CDC_DEVICE 
....................       case USB_DESC_CLASS_TYPE:  //0x21 
....................             //TODO does this work for multiple interfaces or multiple languages? 
....................             //usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][usb_ep0_rx_buffer[4]][usb_ep0_rx_buffer[2]]; 
....................             usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][0][usb_ep0_rx_buffer[2]]; 
092C:  MOVF   3A,W
092D:  MOVLP  00
092E:  CALL   126
092F:  MOVLP  08
0930:  MOVWF  78
0931:  CLRF   7A
0932:  MOVF   78,W
0933:  MOVLB  02
0934:  MOVWF  43
0935:  MOVF   7A,W
0936:  MOVWF  44
....................             if (usb_getdesc_ptr!=0xFF) { 
0937:  INCFSZ 43,W
0938:  GOTO   13C
0939:  MOVF   44,F
093A:  BTFSC  03.2
093B:  GOTO   14C
....................                usb_getdesc_len=USB_CONFIG_DESC[usb_getdesc_ptr]; 
093C:  MOVF   44,W
093D:  MOVWF  7A
093E:  MOVF   43,W
093F:  MOVLP  00
0940:  MOVLB  00
0941:  CALL   0E0
0942:  MOVLP  08
0943:  MOVWF  78
0944:  CLRF   7A
0945:  MOVF   78,W
0946:  MOVLB  02
0947:  MOVWF  45
0948:  MOVF   7A,W
0949:  MOVWF  46
....................                break; 
094A:  GOTO   158
....................             } 
094B:  GOTO   152
....................             else { 
....................                usb_request_stall(); 
094C:  MOVLP  00
094D:  MOVLB  00
094E:  CALL   246
094F:  MOVLP  08
....................                return; 
0950:  GOTO   173
0951:  MOVLB  02
....................             } 
.................... #endif 
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_DESC_HIDREPORT_TYPE: //0x22 
....................             usb_getdesc_ptr=USB_CLASS_SPECIFIC_DESC_LOOKUP[0][usb_ep0_rx_buffer[4]]; 
....................             if (usb_getdesc_ptr !=0xFF) { 
....................                USB_stack_status.getdesc_type=USB_GETDESC_HIDREPORT_TYPE; 
....................                usb_getdesc_len=USB_CLASS_SPECIFIC_DESC_LOOKUP_SIZE[0][usb_ep0_rx_buffer[4]]; 
....................                break; 
....................             } 
....................             else { 
....................                usb_request_stall(); 
....................                return; 
....................             } 
.................... #endif 
....................  
....................       default: 
....................             usb_request_stall(); 
0952:  MOVLP  00
0953:  MOVLB  00
0954:  CALL   246
0955:  MOVLP  08
....................             return; 
0956:  GOTO   173
0957:  MOVLB  02
....................    } 
....................    if (usb_ep0_rx_buffer[7]==0) { 
0958:  MOVLB  00
0959:  MOVF   3F,F
095A:  BTFSS  03.2
095B:  GOTO   16C
....................       if (usb_getdesc_len > usb_ep0_rx_buffer[6]) 
095C:  MOVLB  02
095D:  MOVF   46,F
095E:  BTFSS  03.2
095F:  GOTO   166
0960:  MOVF   45,W
0961:  MOVLB  00
0962:  SUBWF  3E,W
0963:  BTFSC  03.0
0964:  GOTO   16C
0965:  MOVLB  02
....................          usb_getdesc_len = usb_ep0_rx_buffer[6]; 
0966:  CLRF   46
0967:  MOVLB  00
0968:  MOVF   3E,W
0969:  MOVLB  02
096A:  MOVWF  45
096B:  MOVLB  00
....................    } 
....................    USB_stack_status.dev_req=GET_DESCRIPTOR; 
096C:  MOVLW  01
096D:  MOVLB  02
096E:  MOVWF  3C
....................    usb_copy_desc_seg_to_ep(); 
096F:  MOVLP  00
0970:  MOVLB  00
0971:  CALL   249
0972:  MOVLP  08
.................... } 
....................  
.................... /************************************************************** 
.................... /* usb_finish_set_address() 
.................... /* 
.................... /* Input: USB_address_pending holds the address we were asked to set to. 
.................... /* 
.................... /* Summary: Sets the address. 
.................... /* 
.................... /* This code should only be run on the PIC USB peripheral, and not the 
.................... /* National peripheral. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
....................  void usb_finish_set_address() { 
....................    debug_usb_token(debug_putc," FSA "); 
....................    USB_stack_status.curr_config=0;   // make sure current configuration is 0 
*
045E:  CLRF   3D
....................  
....................    #ifdef __PIC__ 
....................    USB_stack_status.dev_req=NONE;  // no request pending 
045F:  CLRF   3C
....................    usb_set_address(USB_address_pending); 
0460:  MOVF   74,W
0461:  MOVLB  04
0462:  MOVWF  61
....................    #endif 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... /// 
.................... /// The following function retrieve data from constant arrays.  This may 
.................... /// look un-optimized, but remember that you can't create a pointer to 
.................... /// a constant array. 
.................... /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... void usb_copy_desc_seg_to_ep(void) { 
*
0249:  MOVLB  04
024A:  CLRF   61
....................    unsigned int i=0; 
....................    char c; 
....................     
....................    //debug_usb(debug_putc, "!%LX! ", &usb_ep0_tx_buffer[0]); 
....................  
....................    while ((usb_getdesc_len)&&(i<USB_MAX_EP0_PACKET_LENGTH)) 
024B:  MOVLB  02
024C:  MOVF   45,W
024D:  IORWF  46,W
024E:  BTFSC  03.2
024F:  GOTO   299
0250:  MOVLB  04
0251:  MOVF   61,W
0252:  SUBLW  07
0253:  BTFSC  03.0
0254:  GOTO   257
0255:  MOVLB  02
0256:  GOTO   299
....................    { 
....................       switch(USB_stack_status.getdesc_type) { 
0257:  MOVLB  02
0258:  MOVF   3F,W
0259:  XORLW  00
025A:  MOVLB  00
025B:  BTFSC  03.2
025C:  GOTO   264
025D:  XORLW  02
025E:  BTFSC  03.2
025F:  GOTO   26F
0260:  XORLW  01
0261:  BTFSC  03.2
0262:  GOTO   27A
0263:  GOTO   284
....................          case USB_GETDESC_CONFIG_TYPE: 
....................             c=USB_CONFIG_DESC[usb_getdesc_ptr]; 
0264:  MOVLB  02
0265:  MOVF   44,W
0266:  MOVWF  7A
0267:  MOVF   43,W
0268:  MOVLB  00
0269:  CALL   0E0
026A:  MOVWF  78
026B:  MOVLB  04
026C:  MOVWF  62
....................             break; 
026D:  MOVLB  00
026E:  GOTO   284
....................  
....................         #IF USB_HID_DEVICE 
....................          case USB_GETDESC_HIDREPORT_TYPE: 
....................             c=USB_CLASS_SPECIFIC_DESC[usb_getdesc_ptr]; 
....................             break; 
....................         #endif 
....................  
....................          case USB_GETDESC_STRING_TYPE: 
....................             c=USB_STRING_DESC[usb_getdesc_ptr]; 
026F:  MOVLB  02
0270:  MOVF   44,W
0271:  MOVWF  7A
0272:  MOVF   43,W
0273:  MOVLB  00
0274:  CALL   04F
0275:  MOVWF  78
0276:  MOVLB  04
0277:  MOVWF  62
....................             break; 
0278:  MOVLB  00
0279:  GOTO   284
....................  
....................          case USB_GETDESC_DEVICE_TYPE: 
....................             c=USB_DEVICE_DESC[usb_getdesc_ptr]; 
027A:  MOVLB  02
027B:  MOVF   44,W
027C:  MOVWF  7A
027D:  MOVF   43,W
027E:  MOVLB  00
027F:  CALL   12F
0280:  MOVWF  78
0281:  MOVLB  04
0282:  MOVWF  62
....................             //debug_usb(debug_putc, "-%X- ", c); 
....................             break; 
0283:  MOVLB  00
....................       } 
....................       usb_getdesc_ptr++; 
0284:  MOVLB  02
0285:  INCF   43,F
0286:  BTFSC  03.2
0287:  INCF   44,F
....................       usb_getdesc_len--; 
0288:  MOVF   45,W
0289:  BTFSC  03.2
028A:  DECF   46,F
028B:  DECF   45,F
....................       usb_ep0_tx_buffer[i++]=c; 
028C:  MOVLB  04
028D:  MOVF   61,W
028E:  INCF   61,F
028F:  ADDLW  20
0290:  MOVWF  04
0291:  MOVLW  20
0292:  MOVWF  05
0293:  BTFSC  03.0
0294:  INCF   05,F
0295:  MOVF   62,W
0296:  MOVWF  00
0297:  GOTO   24B
0298:  MOVLB  02
....................    } 
....................  
....................    if ((!usb_getdesc_len)&&(i!=USB_MAX_EP0_PACKET_LENGTH)) { 
0299:  MOVF   45,W
029A:  IORWF  46,W
029B:  BTFSS  03.2
029C:  GOTO   2A6
029D:  MOVLB  04
029E:  MOVF   61,W
029F:  SUBLW  08
02A0:  BTFSS  03.2
02A1:  GOTO   2A4
02A2:  MOVLB  02
02A3:  GOTO   2A6
....................          USB_stack_status.dev_req = NONE; 
02A4:  MOVLB  02
02A5:  CLRF   3C
....................    } 
....................  
....................    usb_request_send_response(i); 
02A6:  MOVLB  04
02A7:  MOVF   61,W
02A8:  MOVWF  64
02A9:  MOVLB  00
02AA:  CALL   241
02AB:  RETURN
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /* 
....................    Generally, you cannot use CDC on a slow speed USB device.  The primary 
....................    reason for this is that CDC uses bulk transfer endpoints, and bulk 
....................    transfer endpoints is not supported on slow speed devices per the USB 
....................    specification.  You may be able to find unofficial drivers for your 
....................    operating system that allows CDC to operate on a slow speed device, 
....................    but CCS doesn't have any that they can recommend to you. 
.................... */ 
.................... #if (USB_USE_FULL_SPEED==0) 
....................    #error CDC and slow speed is not supported.  See comments above. 
.................... #endif 
....................  
.................... struct { 
....................         unsigned int32   dwDTERrate;   //data terminal rate, in bits per second 
....................         unsigned int8    bCharFormat;  //num of stop bits (0=1, 1=1.5, 2=2) 
....................         unsigned int8    bParityType;  //parity (0=none, 1=odd, 2=even, 3=mark, 4=space) 
....................         unsigned int8    bDataBits;    //data bits (5,6,7,8 or 16) 
.................... } __attribute__((__packed__)) usb_cdc_line_coding; 
....................  
.................... //length of time, in ms, of break signal as we received in a SendBreak message. 
.................... //if ==0xFFFF, send break signal until we receive a 0x0000. 
.................... unsigned int16 usb_cdc_break; 
....................  
.................... #ifndef USB_CDC_DATA_LOCAL_SIZE 
.................... unsigned int8 usb_cdc_put_buffer[USB_CDC_DATA_IN_SIZE-1]; 
.................... #else 
.................... unsigned int8 usb_cdc_put_buffer[USB_CDC_DATA_LOCAL_SIZE]; 
.................... #endif 
....................  
.................... #define usb_cdc_put_buffer_free()  usb_tbe(USB_CDC_DATA_IN_ENDPOINT) 
.................... #if sizeof(usb_cdc_put_buffer)>=0x100 
....................  #error This is not supported.  That is because ISR may change this 16bit value while your non-ISR code is reading this. 
....................  typedef unsigned int16 usb_cdc_tx_t; 
.................... #else 
....................  typedef unsigned int8 usb_cdc_tx_t; 
.................... #endif 
....................  
.................... usb_cdc_tx_t usb_cdc_put_buffer_nextin; 
.................... //#locate usb_cdc_put_buffer_nextin=0x1800 
....................  
....................  
.................... #if defined(__PIC__) 
....................  #define usb_cdc_get_buffer_status_buffer usb_ep2_rx_buffer 
.................... #else 
....................  unsigned int8 usb_cdc_get_buffer_status_buffer[USB_CDC_DATA_OUT_SIZE]; 
.................... #endif 
....................  
.................... int1 usb_cdc_got_set_line_coding; 
....................  
.................... struct  { 
....................    int1 dte_present; //1=DTE present, 0=DTE not present 
....................    int1 active;      //1=activate carrier, 0=deactivate carrier 
....................    unsigned int reserved:6; 
.................... } usb_cdc_carrier; 
....................  
.................... enum {USB_CDC_OUT_NOTHING=0, USB_CDC_OUT_COMMAND=1, USB_CDC_OUT_LINECODING=2, USB_CDC_WAIT_0LEN=3} __usb_cdc_state; 
....................  
.................... /* 
.................... #if defined(__PCH__) 
....................  #byte INTCON=0xFF2 
....................  #bit INT_GIE=INTCON.7 
.................... #else 
....................  #word SR=0x42 
.................... #endif 
.................... */ 
....................  
.................... #if defined(USB_CDC_USE_ENCAPSULATED) 
.................... unsigned int16 g_UsbCdcSendEncapsSize; 
.................... #endif 
....................  
.................... //handle OUT token done interrupt on endpoint 0 [read encapsulated cmd and line coding data] 
.................... void usb_isr_tok_out_cdc_control_dne(void)  
.................... { 
....................    switch (__usb_cdc_state) { 
*
03A0:  MOVF   7C,W
03A1:  XORLW  01
03A2:  MOVLB  00
03A3:  BTFSC  03.2
03A4:  GOTO   3AC
03A5:  XORLW  02
03A6:  BTFSC  03.2
03A7:  GOTO   3B2
03A8:  XORLW  01
03A9:  BTFSC  03.2
03AA:  GOTO   3B8
03AB:  GOTO   3D9
....................       //printf(putc_tbe,"@%X@\r\n", __usb_cdc_state); 
....................       case USB_CDC_OUT_COMMAND: 
....................         #if defined(USB_CDC_USE_ENCAPSULATED) 
....................          usb_cdc_SendEncapsulatedCommand(usb_ep0_rx_buffer, g_UsbCdcSendEncapsSize); 
....................         #endif 
....................          usb_put_0len_0(); 
03AC:  MOVLB  04
03AD:  CLRF   64
03AE:  MOVLB  00
03AF:  CALL   241
....................          __usb_cdc_state=0; 
03B0:  CLRF   7C
....................          break; 
03B1:  GOTO   3DA
....................  
....................     #if USB_MAX_EP0_PACKET_LENGTH==8 
....................       case USB_CDC_WAIT_0LEN: 
....................          usb_put_0len_0(); 
03B2:  MOVLB  04
03B3:  CLRF   64
03B4:  MOVLB  00
03B5:  CALL   241
....................          __usb_cdc_state=0; 
03B6:  CLRF   7C
....................          break; 
03B7:  GOTO   3DA
....................     #endif 
....................  
....................       case USB_CDC_OUT_LINECODING: 
....................          //usb_get_packet(0, &usb_cdc_line_coding, 7); 
....................          //printf(putc_tbe,"\r\n!GSLC FIN!\r\n"); 
....................          memcpy(&usb_cdc_line_coding, usb_ep0_rx_buffer,7); 
03B8:  MOVF   38,W
03B9:  MOVLB  02
03BA:  MOVWF  49
03BB:  MOVLB  00
03BC:  MOVF   39,W
03BD:  MOVLB  02
03BE:  MOVWF  4A
03BF:  MOVLB  00
03C0:  MOVF   3A,W
03C1:  MOVLB  02
03C2:  MOVWF  4B
03C3:  MOVLB  00
03C4:  MOVF   3B,W
03C5:  MOVLB  02
03C6:  MOVWF  4C
03C7:  MOVLB  00
03C8:  MOVF   3C,W
03C9:  MOVLB  02
03CA:  MOVWF  4D
03CB:  MOVLB  00
03CC:  MOVF   3D,W
03CD:  MOVLB  02
03CE:  MOVWF  4E
03CF:  MOVLB  00
03D0:  MOVF   3E,W
03D1:  MOVLB  02
03D2:  MOVWF  4F
....................          __usb_cdc_state=0; 
03D3:  CLRF   7C
....................          usb_put_0len_0(); 
03D4:  MOVLB  04
03D5:  CLRF   64
03D6:  MOVLB  00
03D7:  CALL   241
....................          break; 
03D8:  GOTO   3DA
....................  
....................       default: 
....................          __usb_cdc_state=0; 
03D9:  CLRF   7C
....................          //usb_init_ep0_setup(); //REMOVED JUN/9/2009 
....................          break; 
....................    } 
.................... } 
....................  
.................... //handle IN token on 0 (setup packet) 
.................... void usb_isr_tkn_cdc(void) { 
....................    unsigned int16 wLen; 
....................    //make sure the request goes to a CDC interface 
....................    if ((usb_ep0_rx_buffer[4] == 1) || (usb_ep0_rx_buffer[4] == 0)) { 
*
0B75:  DECFSZ 3C,W
0B76:  GOTO   378
0B77:  GOTO   37B
0B78:  MOVF   3C,F
0B79:  BTFSS  03.2
0B7A:  GOTO   3E9
....................       wLen = make16(usb_ep0_rx_buffer[7], usb_ep0_rx_buffer[6]); 
0B7B:  MOVF   3F,W
0B7C:  MOVLB  04
0B7D:  MOVWF  61
0B7E:  MOVLB  00
0B7F:  MOVF   3E,W
0B80:  MOVLB  04
0B81:  MOVWF  60
....................       //printf(putc_tbe,"!%X!\r\n", usb_ep0_rx_buffer[1]); 
....................       switch(usb_ep0_rx_buffer[1]) { 
0B82:  MOVLB  00
0B83:  MOVF   39,W
0B84:  BTFSC  03.2
0B85:  GOTO   396
0B86:  XORLW  01
0B87:  BTFSC  03.2
0B88:  GOTO   39C
0B89:  XORLW  21
0B8A:  BTFSC  03.2
0B8B:  GOTO   3A4
0B8C:  XORLW  01
0B8D:  BTFSC  03.2
0B8E:  GOTO   3AB
0B8F:  XORLW  03
0B90:  BTFSC  03.2
0B91:  GOTO   3CF
0B92:  XORLW  01
0B93:  BTFSC  03.2
0B94:  GOTO   3D8
0B95:  GOTO   3E6
....................          case 0x00:  //send_encapsulated_command 
....................            #if defined(USB_CDC_USE_ENCAPSULATED) 
....................             g_UsbCdcSendEncapsSize = wLen; 
....................            #endif 
....................             __usb_cdc_state=USB_CDC_OUT_COMMAND; 
0B96:  MOVLW  01
0B97:  MOVWF  7C
....................             usb_request_get_data(); 
0B98:  MOVLP  00
0B99:  CALL   2AC
0B9A:  MOVLP  08
....................             break; 
0B9B:  GOTO   3E9
....................  
....................          case 0x01:  //get_encapsulated_command 
....................            #if defined(USB_CDC_USE_ENCAPSULATED) 
....................             usb_cdc_GetEncapsulatedResponse(usb_ep0_tx_buffer, wLen); 
....................            #endif 
....................             usb_request_send_response(wLen); 
0B9C:  MOVLB  04
0B9D:  MOVF   60,W
0B9E:  MOVWF  64
0B9F:  MOVLP  00
0BA0:  MOVLB  00
0BA1:  CALL   241
0BA2:  MOVLP  08
....................             break; 
0BA3:  GOTO   3E9
....................  
....................          case 0x20:  //set_line_coding 
....................             __usb_cdc_state=USB_CDC_OUT_LINECODING; 
0BA4:  MOVLW  02
0BA5:  MOVWF  7C
....................             usb_cdc_got_set_line_coding=TRUE; 
0BA6:  BSF    76.0
....................             usb_request_get_data(); 
0BA7:  MOVLP  00
0BA8:  CALL   2AC
0BA9:  MOVLP  08
....................             break; 
0BAA:  GOTO   3E9
....................  
....................          case 0x21:  //get_line_coding 
....................             memcpy(usb_ep0_tx_buffer, &usb_cdc_line_coding, sizeof(usb_cdc_line_coding)); 
0BAB:  MOVLB  02
0BAC:  MOVF   49,W
0BAD:  MOVLB  00
0BAE:  MOVWF  40
0BAF:  MOVLB  02
0BB0:  MOVF   4A,W
0BB1:  MOVLB  00
0BB2:  MOVWF  41
0BB3:  MOVLB  02
0BB4:  MOVF   4B,W
0BB5:  MOVLB  00
0BB6:  MOVWF  42
0BB7:  MOVLB  02
0BB8:  MOVF   4C,W
0BB9:  MOVLB  00
0BBA:  MOVWF  43
0BBB:  MOVLB  02
0BBC:  MOVF   4D,W
0BBD:  MOVLB  00
0BBE:  MOVWF  44
0BBF:  MOVLB  02
0BC0:  MOVF   4E,W
0BC1:  MOVLB  00
0BC2:  MOVWF  45
0BC3:  MOVLB  02
0BC4:  MOVF   4F,W
0BC5:  MOVLB  00
0BC6:  MOVWF  46
....................             usb_request_send_response(sizeof(usb_cdc_line_coding)); //send wLength bytes 
0BC7:  MOVLW  07
0BC8:  MOVLB  04
0BC9:  MOVWF  64
0BCA:  MOVLP  00
0BCB:  MOVLB  00
0BCC:  CALL   241
0BCD:  MOVLP  08
....................             break; 
0BCE:  GOTO   3E9
....................  
....................          case 0x22:  //set_control_line_state 
....................             (unsigned int8)usb_cdc_carrier=usb_ep0_rx_buffer[2]; 
0BCF:  MOVF   3A,W
0BD0:  MOVWF  7B
....................             usb_put_0len_0(); 
0BD1:  MOVLB  04
0BD2:  CLRF   64
0BD3:  MOVLP  00
0BD4:  MOVLB  00
0BD5:  CALL   241
0BD6:  MOVLP  08
....................             break; 
0BD7:  GOTO   3E9
....................  
....................          case 0x23:  //send_break 
....................             usb_cdc_break=make16(usb_ep0_rx_buffer[2],usb_ep0_rx_buffer[3]); 
0BD8:  MOVF   3A,W
0BD9:  MOVLB  02
0BDA:  MOVWF  51
0BDB:  MOVLB  00
0BDC:  MOVF   3B,W
0BDD:  MOVLB  02
0BDE:  MOVWF  50
....................             usb_put_0len_0(); 
0BDF:  MOVLB  04
0BE0:  CLRF   64
0BE1:  MOVLP  00
0BE2:  MOVLB  00
0BE3:  CALL   241
0BE4:  MOVLP  08
....................             break; 
0BE5:  GOTO   3E9
....................  
....................          default: 
....................             usb_request_stall(); 
0BE6:  MOVLP  00
0BE7:  CALL   246
0BE8:  MOVLP  08
....................             break; 
....................       } 
....................    } 
.................... } 
....................  
.................... //handle OUT token done interrupt on endpoint 2 [buffer incoming received chars] 
.................... void usb_isr_tok_out_cdc_data_dne(void) { 
....................    usb_cdc_get_buffer_status.got=TRUE; 
*
03E0:  MOVLB  02
03E1:  BSF    40.0
....................    usb_cdc_get_buffer_status.index=0; 
03E2:  CLRF   42
.................... #if (defined(__PIC__) && __PIC__) 
....................     usb_cdc_get_buffer_status.len=usb_rx_packet_size(USB_CDC_DATA_OUT_ENDPOINT); 
03E3:  MOVLW  02
03E4:  MOVLB  04
03E5:  MOVWF  61
*
03F6:  MOVF   78,W
03F7:  MOVLB  02
03F8:  MOVWF  41
.................... #else 
....................    usb_cdc_get_buffer_status.len=usb_get_packet_buffer( 
....................       USB_CDC_DATA_OUT_ENDPOINT,&usb_cdc_get_buffer_status_buffer[0],USB_CDC_DATA_OUT_SIZE); 
.................... #endif 
....................    if (!usb_cdc_get_buffer_status.len) 
03F9:  MOVF   41,F
03FA:  BTFSS  03.2
03FB:  GOTO   3FF
....................    { 
....................       usb_cdc_get_discard(); 
03FC:  MOVLB  00
03FD:  CALL   393
03FE:  MOVLB  02
03FF:  MOVLB  04
....................    } 
....................    /* 
....................   #if defined(USB_CDC_ISR) 
....................    else 
....................    { 
....................       USB_CDC_ISR(); 
....................    } 
....................   #endif 
....................   */ 
.................... } 
....................  
.................... //handle IN token done interrupt on endpoint 2 [transmit buffered characters] 
.................... void usb_isr_tok_in_cdc_data_dne(void)  
.................... { 
....................    usb_cdc_flush_tx_buffer(); 
*
0477:  MOVLB  00
0478:  CALL   43A
0479:  MOVLB  04
.................... } 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
*
05EE:  MOVLB  03
05EF:  MOVF   6B,W
05F0:  MOVWF  7A
05F1:  MOVF   6A,W
05F2:  MOVWF  04
05F3:  MOVF   7A,W
05F4:  MOVWF  05
05F5:  MOVF   00,F
05F6:  BTFSC  03.2
05F7:  GOTO   63E
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
05F8:  MOVF   6B,W
05F9:  MOVWF  6F
05FA:  MOVF   6A,W
05FB:  MOVWF  6E
05FC:  MOVF   6D,W
05FD:  MOVLB  04
05FE:  MOVWF  21
05FF:  MOVLB  03
0600:  MOVF   6C,W
0601:  MOVLB  04
0602:  MOVWF  20
0603:  MOVF   21,W
0604:  MOVWF  7A
0605:  MOVF   20,W
0606:  MOVWF  04
0607:  MOVF   7A,W
0608:  MOVWF  05
0609:  MOVF   00,F
060A:  BTFSC  03.2
060B:  GOTO   629
060C:  MOVLB  03
060D:  MOVF   6F,W
060E:  MOVWF  7A
060F:  MOVF   6E,W
0610:  MOVWF  04
0611:  MOVF   7A,W
0612:  MOVWF  05
0613:  MOVF   00,W
0614:  MOVLB  04
0615:  MOVWF  22
0616:  MOVF   21,W
0617:  MOVWF  7A
0618:  MOVF   20,W
0619:  MOVWF  04
061A:  MOVF   7A,W
061B:  MOVWF  05
061C:  MOVF   00,W
061D:  SUBWF  22,W
061E:  BTFSS  03.2
061F:  GOTO   629
0620:  MOVLB  03
0621:  INCF   6E,F
0622:  BTFSC  03.2
0623:  INCF   6F,F
0624:  MOVLB  04
0625:  INCF   20,F
0626:  BTFSC  03.2
0627:  INCF   21,F
0628:  GOTO   603
....................  
....................       if (*t == '\0') 
0629:  MOVF   21,W
062A:  MOVWF  7A
062B:  MOVF   20,W
062C:  MOVWF  04
062D:  MOVF   7A,W
062E:  MOVWF  05
062F:  MOVF   00,F
0630:  BTFSS  03.2
0631:  GOTO   639
....................          return s1; 
0632:  MOVLB  03
0633:  MOVF   6A,W
0634:  MOVWF  78
0635:  MOVF   6B,W
0636:  MOVWF  79
0637:  GOTO   641
0638:  MOVLB  04
....................       ++s1; 
0639:  MOVLB  03
063A:  INCF   6A,F
063B:  BTFSC  03.2
063C:  INCF   6B,F
....................       #ifdef FASTER_BUT_MORE_ROM 
063D:  GOTO   5EF
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
063E:  MOVLW  00
063F:  MOVWF  78
0640:  MOVWF  79
0641:  MOVLB  00
0642:  RETURN
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... void usb_cdc_flush_tx_buffer(void)  
.................... { 
....................   #ifdef USB_CDC_DATA_LOCAL_SIZE 
....................    usb_cdc_tx_t n; 
....................   #endif 
....................    
....................    if (usb_cdc_put_buffer_nextin != 0) 
*
043A:  MOVF   75,F
043B:  BTFSC  03.2
043C:  GOTO   44E
....................    { 
....................      #ifndef USB_CDC_DATA_LOCAL_SIZE 
....................       if (usb_put_packet(USB_CDC_DATA_IN_ENDPOINT,usb_cdc_put_buffer,usb_cdc_put_buffer_nextin,USB_DTS_TOGGLE)) 
043D:  MOVLW  02
043E:  MOVLB  04
043F:  MOVWF  61
0440:  MOVLW  20
0441:  MOVWF  63
0442:  MOVLW  D2
0443:  MOVWF  62
0444:  CLRF   65
0445:  MOVF   75,W
0446:  MOVWF  64
0447:  MOVLW  02
0448:  MOVWF  66
0449:  MOVLB  00
044A:  CALL   402
044B:  MOVF   78,F
044C:  BTFSS  03.2
....................       { 
....................          usb_cdc_put_buffer_nextin = 0; 
044D:  CLRF   75
....................       } 
....................      #else 
....................       n = usb_cdc_put_buffer_nextin; 
....................       if (n > (USB_CDC_DATA_IN_SIZE-1)) //always send one less than packet size so we don't have to deal with 0 len packets 
....................          n = USB_CDC_DATA_IN_SIZE-1; 
....................       if (usb_put_packet(USB_CDC_DATA_IN_ENDPOINT,usb_cdc_put_buffer,n,USB_DTS_TOGGLE)) 
....................       { 
....................          //pull the buffer back 
....................          memmove(usb_cdc_put_buffer, &usb_cdc_put_buffer[n], usb_cdc_put_buffer_nextin-n); 
....................          usb_cdc_put_buffer_nextin -= n; 
....................       }       
....................      #endif 
....................    } 
044E:  RETURN
.................... } 
....................  
.................... void usb_cdc_init(void)  
.................... { 
....................    usb_cdc_line_coding.dwDTERrate = 9600; 
*
01F8:  MOVLB  04
01F9:  CLRF   63
01FA:  CLRF   62
01FB:  MOVLW  25
01FC:  MOVWF  61
01FD:  MOVLW  80
01FE:  MOVWF  60
01FF:  MOVF   60,W
0200:  MOVLB  02
0201:  MOVWF  49
0202:  MOVLB  04
0203:  MOVF   61,W
0204:  MOVLB  02
0205:  MOVWF  4A
0206:  CLRF   4B
0207:  CLRF   4C
....................    usb_cdc_line_coding.bCharFormat = 0; 
0208:  MOVLB  04
0209:  CLRF   60
020A:  MOVF   60,W
020B:  MOVLB  02
020C:  MOVWF  4D
....................    usb_cdc_line_coding.bParityType = 0; 
020D:  MOVLB  04
020E:  CLRF   60
020F:  MOVF   60,W
0210:  MOVLB  02
0211:  MOVWF  4E
....................    usb_cdc_line_coding.bDataBits = 8; 
0212:  MOVLW  08
0213:  MOVLB  04
0214:  MOVWF  60
0215:  MOVF   60,W
0216:  MOVLB  02
0217:  MOVWF  4F
....................    (int8)usb_cdc_carrier = 0; 
0218:  CLRF   7B
....................    usb_cdc_got_set_line_coding = FALSE; 
0219:  BCF    76.0
....................    usb_cdc_break = 0; 
021A:  CLRF   51
021B:  CLRF   50
....................    usb_cdc_put_buffer_nextin = 0; 
021C:  CLRF   75
....................    usb_cdc_get_buffer_status.got = 0; 
021D:  BCF    40.0
....................    __usb_cdc_state = 0; 
021E:  CLRF   7C
021F:  MOVLB  00
0220:  RETURN
.................... } 
....................  
.................... ////////////////// END USB CONTROL HANDLING ////////////////////////////////// 
....................  
.................... ////////////////// BEGIN USB<->RS232 CDC LIBRARY ///////////////////////////// 
....................  
.................... typedef struct 
.................... { 
....................    unsigned int bRxCarrier:1; //State of receiver carrier detection mechanism of device. This signal corresponds to V.24 signal 109 and RS-232 signal DCD. 
....................    unsigned int bTxCarrier:1; //State of transmission carrier. This signal corresponds to V.24 signal 106 and RS-232 signal DSR 
....................    unsigned int bBreak:1;  //State of break detection mechanism of the device. 
....................    unsigned int bRingSignal:1;   //State of ring signal detection of the device.  
....................    unsigned int bFraming:1;   //A framing error has occurred. 
....................    unsigned int bParity:1;    //A parity error has occurred. 
....................    unsigned int bOverRun:1;   //Received data has been discarded due to overrun in the device. 
....................    unsigned int reserved0:1;   //future use 
....................    unsigned int reserved1:8;   //future use 
.................... } cdc_serial_state_t; 
....................  
.................... /* 
....................    Send SERIAL_STATE notification to the host.  This contains DSR, DCD, Ring,  
....................    break signal and more (see cdc_serial_state_t). 
....................    Some of these values are held by the host (meaning it's value only needs 
....................    to be sent on change), but some values are one shot (meaning you continously 
....................    need to send value to host while being held). 
.................... */ 
.................... int1 usb_cdc_serial_state(cdc_serial_state_t state) 
.................... { 
....................   #if __USB_PIC_PERIF__ 
....................    #define CDC_EP1_NOTIFY_BUFFER usb_ep1_tx_buffer 
....................   #else 
....................    unsigned int8 payload[10]; 
....................    #define CDC_EP1_NOTIFY_BUFFER payload 
....................   #endif 
....................  
....................    if (!usb_tbe(USB_CDC_COMM_IN_ENDPOINT)) 
....................       return(FALSE); 
....................  
....................    //bmRequestType 
....................    CDC_EP1_NOTIFY_BUFFER[0] = 0xA1;  //0b10100001 
....................    //bNotification 
....................    CDC_EP1_NOTIFY_BUFFER[1] = 0x20;  //SERIAL_STATE 
....................    //wValue 
....................    CDC_EP1_NOTIFY_BUFFER[2] = 0; 
....................    CDC_EP1_NOTIFY_BUFFER[3] = 0; 
....................    //wIndex 
....................    CDC_EP1_NOTIFY_BUFFER[4] = 0; 
....................    CDC_EP1_NOTIFY_BUFFER[5] = 0; 
....................    //wLength 
....................    CDC_EP1_NOTIFY_BUFFER[6] = 2; //sizeof(cdc_serial_state_t) 
....................    CDC_EP1_NOTIFY_BUFFER[7] = 0; 
....................    //data 
....................    CDC_EP1_NOTIFY_BUFFER[8] = (unsigned int8)state; 
....................    CDC_EP1_NOTIFY_BUFFER[9] = (unsigned int16)state >> 8; 
....................  
....................   #if __USB_PIC_PERIF__ 
....................    usb_flush_in(USB_CDC_COMM_IN_ENDPOINT, 10, USB_DTS_TOGGLE); 
....................   #else 
....................    usb_put_packet(USB_CDC_COMM_IN_ENDPOINT, payload, 10, USB_DTS_TOGGLE); 
....................   #endif 
....................     
....................    return(TRUE); 
.................... } 
....................  
.................... void usb_cdc_get_discard(void) 
.................... { 
....................    usb_cdc_get_buffer_status.got = FALSE; 
*
0393:  MOVLB  02
0394:  BCF    40.0
....................    usb_flush_out(USB_CDC_DATA_OUT_ENDPOINT, USB_DTS_TOGGLE); 
0395:  MOVLW  02
0396:  MOVLB  04
0397:  MOVWF  61
0398:  MOVWF  62
0399:  MOVLB  00
039A:  CALL   2AF
039B:  RETURN
.................... } 
....................  
.................... char usb_cdc_getc(void)  
.................... { 
....................    char c; 
....................  
....................    while (!usb_cdc_kbhit())  
*
05C6:  MOVLB  02
05C7:  BTFSS  40.0
....................    { 
....................      #if defined(USB_ISR_POLLING) 
05C8:  GOTO   5C7
....................       usb_task(); 
....................      #endif 
....................    } 
....................  
....................    c=usb_cdc_get_buffer_status_buffer[usb_cdc_get_buffer_status.index++]; 
05C9:  MOVF   42,W
05CA:  INCF   42,F
05CB:  ADDLW  33
05CC:  MOVWF  04
05CD:  MOVLW  20
05CE:  MOVWF  05
05CF:  BTFSC  03.0
05D0:  INCF   05,F
05D1:  MOVF   00,W
05D2:  MOVLB  03
05D3:  MOVWF  5B
....................  
....................    if (usb_cdc_get_buffer_status.index >= usb_cdc_get_buffer_status.len)  
05D4:  MOVLB  02
05D5:  MOVF   41,W
05D6:  SUBWF  42,W
05D7:  BTFSS  03.0
05D8:  GOTO   5E2
05D9:  CLRF   3B
05DA:  BTFSC  0B.7
05DB:  BSF    3B.7
05DC:  BCF    0B.7
....................    { 
....................       usb_cdc_get_discard(); 
05DD:  MOVLB  00
05DE:  CALL   393
05DF:  MOVLB  02
05E0:  BTFSC  3B.7
05E1:  BSF    0B.7
....................    } 
....................  
....................    return(c); 
05E2:  MOVLB  03
05E3:  MOVF   5B,W
05E4:  MOVWF  78
05E5:  MOVLP  00
05E6:  MOVLB  00
05E7:  GOTO   733 (RETURN)
.................... } 
....................  
.................... #if defined(USB_ISR_POLLING) 
.................... #define __USB_PAUSE_ISR() 
.................... #define __USB_RESTORE_ISR() 
.................... #else 
.................... #define __USB_PAUSE_ISR()  int1 old_usbie; old_usbie = USBIE; USBIE = 0 
.................... #define __USB_RESTORE_ISR() if (old_usbie) USBIE = 1 
.................... #endif 
....................  
.................... static void _usb_cdc_putc_fast_noflush(char c) 
.................... { 
....................    __USB_PAUSE_ISR(); 
*
0668:  MOVLB  04
0669:  BCF    20.0
066A:  MOVLB  01
066B:  BTFSS  12.2
066C:  GOTO   670
066D:  MOVLB  04
066E:  BSF    20.0
066F:  MOVLB  01
0670:  BCF    12.2
....................  
....................   #if defined(USB_CDC_DELAYED_FLUSH) 
....................    if (usb_cdc_put_buffer_nextin >= sizeof(usb_cdc_put_buffer))  
....................    { 
....................       usb_cdc_flush_tx_buffer(); 
....................    } 
....................   #endif 
....................  
....................    if (usb_cdc_put_buffer_nextin >= sizeof(usb_cdc_put_buffer)) { 
0671:  MOVF   75,W
0672:  SUBLW  3E
0673:  BTFSC  03.0
0674:  GOTO   677
....................       usb_cdc_put_buffer_nextin = sizeof(usb_cdc_put_buffer)-1;  //we just overflowed the buffer! 
0675:  MOVLW  3E
0676:  MOVWF  75
....................    } 
....................     
....................    usb_cdc_put_buffer[usb_cdc_put_buffer_nextin++] = c; 
0677:  MOVF   75,W
0678:  INCF   75,F
0679:  ADDLW  D2
067A:  MOVWF  04
067B:  MOVLW  20
067C:  MOVWF  05
067D:  BTFSC  03.0
067E:  INCF   05,F
067F:  MOVLB  03
0680:  MOVF   6F,W
0681:  MOVWF  00
....................  
....................    __USB_RESTORE_ISR(); 
0682:  MOVLB  04
0683:  BTFSS  20.0
0684:  GOTO   688
0685:  MOVLB  01
0686:  BSF    12.2
0687:  MOVLB  04
0688:  MOVLB  02
0689:  CLRF   3B
068A:  BTFSC  0B.7
068B:  BSF    3B.7
068C:  BCF    0B.7
.................... } 
....................  
.................... void usb_cdc_putc_fast(char c) 
.................... { 
....................    _usb_cdc_putc_fast_noflush(c); 
*
0666:  MOVF   6E,W
0667:  MOVWF  6F
....................  
....................   #if defined(USB_ISR_POLLING) 
....................    // if interrupts are disabled, we should clear all activity isrs 
....................    // before we attempt to put any data onto an endpoint. 
....................    if (!usb_tbe(USB_CDC_DATA_IN_ENDPOINT)) 
....................       return; 
....................    usb_task(); 
....................   #endif 
....................    
....................   #if !defined(USB_CDC_DELAYED_FLUSH) 
....................    //if (usb_cdc_put_buffer_free())  
....................    { 
....................       //printf("FL2 %LU\r\n", (int16)usb_cdc_put_buffer_nextin); 
....................       usb_cdc_flush_tx_buffer(); 
*
068D:  MOVLB  00
068E:  CALL   43A
068F:  MOVLB  02
0690:  BTFSC  3B.7
0691:  BSF    0B.7
....................    } 
....................   #endif 
....................  
....................    //putc('*'); 
.................... } 
....................  
.................... void usb_cdc_putc(char c) 
.................... { 
....................    while (!usb_cdc_putready())  
*
0643:  MOVF   75,W
0644:  SUBLW  3F
0645:  XORLW  00
0646:  BTFSS  03.2
0647:  GOTO   663
0648:  MOVLB  02
0649:  CLRF   3B
064A:  BTFSC  0B.7
064B:  BSF    3B.7
064C:  BCF    0B.7
....................    { 
....................      #if 1 
....................       if (usb_cdc_put_buffer_free())  
064D:  MOVLW  02
064E:  MOVLB  04
064F:  MOVWF  6E
0650:  MOVLB  00
0651:  CALL   30F
0652:  MOVLB  02
0653:  BTFSC  3B.7
0654:  BSF    0B.7
0655:  MOVF   78,F
0656:  BTFSC  03.2
0657:  GOTO   661
0658:  CLRF   3B
0659:  BTFSC  0B.7
065A:  BSF    3B.7
065B:  BCF    0B.7
....................       { 
....................          usb_cdc_flush_tx_buffer(); 
065C:  MOVLB  00
065D:  CALL   43A
065E:  MOVLB  02
065F:  BTFSC  3B.7
0660:  BSF    0B.7
....................       } 
....................      #endif 
....................  
....................      #if defined(USB_ISR_POLLING) 
0661:  MOVLB  00
0662:  GOTO   643
....................       usb_task(); 
....................      #endif 
....................    } 
....................    usb_cdc_putc_fast(c); 
0663:  MOVLB  03
0664:  MOVF   6D,W
0665:  MOVWF  6E
*
0692:  MOVLB  00
0693:  RETURN
.................... } 
....................  
.................... int1 usb_cdc_putd(unsigned char *ptr, unsigned int8 len) 
.................... { 
....................  #if USB_EP2_TX_SIZE>=0x100 
....................    unsigned int16 i; 
....................  #else 
....................    unsigned int8 i; 
....................  #endif 
....................    char c; 
....................     
....................    i = 0; 
....................     
....................    if (!usb_cdc_put_buffer_free()) 
....................       return(FALSE); 
....................     
....................    while(len--) 
....................    { 
....................       c = *ptr++; 
....................       _usb_cdc_putc_fast_noflush(c); 
....................       if (++i >= USB_EP2_TX_SIZE) 
....................          break; 
....................    } 
....................     
....................    usb_cdc_flush_tx_buffer(); 
....................     
....................    return(TRUE); 
.................... } 
....................  
.................... int1 usb_cdc_puts(char *ptr) 
.................... {    
....................    unsigned int8 len; 
....................  
....................    len = strlen(ptr); 
....................    
....................    return(usb_cdc_putd(ptr, len)); 
.................... } 
....................  
.................... #endif //__USB_CDC_HELPERS_ONLY__ 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... BYTE gethex1_usb()  
.................... { 
....................    char digit; 
....................  
....................    digit = usb_cdc_getc(); 
....................  
....................    usb_cdc_putc(digit); 
....................  
....................    if(digit<='9') 
....................      return(digit-'0'); 
....................    else 
....................      return((toupper(digit)-'A')+10); 
.................... } 
....................  
.................... BYTE gethex_usb() { 
....................    unsigned int8 lo,hi; 
....................  
....................    hi = gethex1_usb(); 
....................    lo = gethex1_usb(); 
....................    if(lo==0xdd) 
....................      return(hi); 
....................    else 
....................      return( hi*16+lo ); 
.................... } 
....................  
.................... void get_string_usb(char* s, unsigned int max) { 
....................    unsigned int len; 
....................    char c; 
....................  
....................    --max; 
....................    len=0; 
....................    do { 
....................      c=usb_cdc_getc(); 
....................      if(c==8) {  // Backspace 
....................         if(len>0) { 
....................           len--; 
....................           usb_cdc_putc(c); 
....................           usb_cdc_putc(' '); 
....................           usb_cdc_putc(c); 
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
....................        if(len<max) { 
....................          s[len++]=c; 
....................          usb_cdc_putc(c); 
....................        } 
....................    } while(c!=13); 
....................    s[len]=0; 
.................... } 
....................  
....................  
.................... // stdlib.h is required for the ato_ conversions 
.................... // in the following functions 
.................... #ifdef _STDLIB 
....................  
.................... signed int get_int_usb() { 
....................   char s[7]; 
....................   signed int i; 
....................  
....................   get_string_usb(s, 7); 
....................  
....................   i=atoi(s); 
....................   return(i); 
.................... } 
....................  
.................... signed long get_long_usb() { 
....................   char s[13]; 
....................   signed long l; 
....................  
....................   get_string_usb(s, 13); 
....................   l=atol(s); 
....................   return(l); 
.................... } 
....................  
.................... float get_float_usb() { 
....................   char s[20]; 
....................   float f; 
....................  
....................   get_string_usb(s, 20); 
....................   f = atof(s); 
....................   return(f); 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... void ATcommands(char); 
.................... void CheckUart(void); 
....................  
.................... void ATcommands(char c){ 
.................... static char buffer[16]={"               "}; 
....................  
....................    buffer[14]=c; 
*
0C6A:  MOVLB  03
0C6B:  MOVF   5B,W
0C6C:  MOVWF  51
....................    for(int i=0;i<14;i++){ 
0C6D:  CLRF   5C
0C6E:  MOVF   5C,W
0C6F:  SUBLW  0D
0C70:  BTFSS  03.0
0C71:  GOTO   48B
....................       buffer[i]=buffer[i+1]; 
0C72:  MOVLW  13
0C73:  ADDWF  5C,W
0C74:  MOVWF  68
0C75:  MOVLW  21
0C76:  MOVWF  69
0C77:  BTFSC  03.0
0C78:  INCF   69,F
0C79:  MOVLW  01
0C7A:  ADDWF  5C,W
0C7B:  ADDLW  13
0C7C:  MOVWF  04
0C7D:  MOVLW  21
0C7E:  MOVWF  05
0C7F:  BTFSC  03.0
0C80:  INCF   05,F
0C81:  MOVF   00,W
0C82:  MOVWF  6A
0C83:  MOVF   69,W
0C84:  MOVWF  05
0C85:  MOVF   68,W
0C86:  MOVWF  04
0C87:  MOVF   6A,W
0C88:  MOVWF  00
0C89:  INCF   5C,F
0C8A:  GOTO   46E
....................    } 
....................     
....................    if(c=='\r'){ 
0C8B:  MOVF   5B,W
0C8C:  SUBLW  0D
0C8D:  BTFSS  03.2
0C8E:  GOTO   64C
....................       if(strstr(buffer,"AT+BOOT\r")!=0){ 
0C8F:  CLRF   78
0C90:  MOVLW  09
0C91:  MOVWF  77
0C92:  MOVLW  21
0C93:  MOVWF  05
0C94:  MOVLW  2D
0C95:  MOVWF  04
0C96:  MOVF   78,W
0C97:  MOVLP  00
0C98:  MOVLB  00
0C99:  CALL   142
0C9A:  MOVLP  08
0C9B:  MOVWF  00
0C9C:  INCF   78,F
0C9D:  ADDFSR 01,FSR0
0C9E:  DECFSZ 77,F
0C9F:  GOTO   4A1
0CA0:  GOTO   4A3
0CA1:  MOVLB  03
0CA2:  GOTO   496
0CA3:  MOVLW  21
0CA4:  MOVLB  03
0CA5:  MOVWF  6B
0CA6:  MOVLW  13
0CA7:  MOVWF  6A
0CA8:  MOVLW  21
0CA9:  MOVWF  6D
0CAA:  MOVLW  2D
0CAB:  MOVWF  6C
0CAC:  MOVLP  00
0CAD:  MOVLB  00
0CAE:  CALL   5EE
0CAF:  MOVLP  08
0CB0:  MOVF   79,W
0CB1:  MOVLB  03
0CB2:  MOVWF  6B
0CB3:  MOVF   78,W
0CB4:  MOVWF  6A
0CB5:  MOVF   6A,F
0CB6:  BTFSS  03.2
0CB7:  GOTO   4BB
0CB8:  MOVF   6B,F
0CB9:  BTFSC  03.2
0CBA:  GOTO   4F1
....................          usb_cdc_putc("ACK\r\n"); 
0CBB:  MOVLW  7C
0CBC:  MOVWF  11
0CBD:  MOVLW  04
0CBE:  MOVWF  12
0CBF:  MOVLP  00
0CC0:  MOVLB  00
0CC1:  CALL   694
0CC2:  MOVLP  08
....................          output_high(RESET1938); 
0CC3:  MOVLW  E1
0CC4:  MOVLB  01
0CC5:  MOVWF  0E
0CC6:  MOVLB  02
0CC7:  BSF    0E.1
....................          delay_us(1); 
0CC8:  MOVLW  03
0CC9:  MOVWF  77
0CCA:  DECFSZ 77,F
0CCB:  GOTO   4CA
0CCC:  GOTO   4CD
....................          output_low(RESET1938); 
0CCD:  MOVLW  E1
0CCE:  MOVLB  01
0CCF:  MOVWF  0E
0CD0:  MOVLB  02
0CD1:  BCF    0E.1
....................          delay_ms(10); 
0CD2:  MOVLW  0A
0CD3:  MOVLB  03
0CD4:  MOVWF  68
....................          putc(0x07); 
*
0CEA:  MOVLW  07
0CEB:  MOVLP  00
0CEC:  MOVLB  00
0CED:  CALL   5E8
0CEE:  MOVLP  08
....................           
....................       } 
0CEF:  GOTO   633
0CF0:  MOVLB  03
....................       else if(strstr(buffer,"AT+RST\r")!=0){ 
0CF1:  CLRF   78
0CF2:  MOVLW  08
0CF3:  MOVWF  77
0CF4:  MOVLW  21
0CF5:  MOVWF  05
0CF6:  MOVLW  2D
0CF7:  MOVWF  04
0CF8:  MOVF   78,W
0CF9:  MOVLP  00
0CFA:  MOVLB  00
0CFB:  CALL   14C
0CFC:  MOVLP  08
0CFD:  MOVWF  00
0CFE:  INCF   78,F
0CFF:  ADDFSR 01,FSR0
0D00:  DECFSZ 77,F
0D01:  GOTO   503
0D02:  GOTO   505
0D03:  MOVLB  03
0D04:  GOTO   4F8
0D05:  MOVLW  21
0D06:  MOVLB  03
0D07:  MOVWF  6B
0D08:  MOVLW  13
0D09:  MOVWF  6A
0D0A:  MOVLW  21
0D0B:  MOVWF  6D
0D0C:  MOVLW  2D
0D0D:  MOVWF  6C
0D0E:  MOVLP  00
0D0F:  MOVLB  00
0D10:  CALL   5EE
0D11:  MOVLP  08
0D12:  MOVF   79,W
0D13:  MOVLB  03
0D14:  MOVWF  6B
0D15:  MOVF   78,W
0D16:  MOVWF  6A
0D17:  MOVF   6A,F
0D18:  BTFSS  03.2
0D19:  GOTO   51D
0D1A:  MOVF   6B,F
0D1B:  BTFSC  03.2
0D1C:  GOTO   536
....................          usb_cdc_putc("ACK\r\n"); 
0D1D:  MOVLW  7F
0D1E:  MOVWF  11
0D1F:  MOVLW  04
0D20:  MOVWF  12
0D21:  MOVLP  00
0D22:  MOVLB  00
0D23:  CALL   694
0D24:  MOVLP  08
....................          output_high(RESET1938); 
0D25:  MOVLW  E1
0D26:  MOVLB  01
0D27:  MOVWF  0E
0D28:  MOVLB  02
0D29:  BSF    0E.1
....................          delay_us(1); 
0D2A:  MOVLW  03
0D2B:  MOVWF  77
0D2C:  DECFSZ 77,F
0D2D:  GOTO   52C
0D2E:  GOTO   52F
....................          output_low(RESET1938); 
0D2F:  MOVLW  E1
0D30:  MOVLB  01
0D31:  MOVWF  0E
0D32:  MOVLB  02
0D33:  BCF    0E.1
....................           
....................       } 
0D34:  GOTO   634
0D35:  MOVLB  03
....................       else if(strstr(buffer,"AT+INFO\r")!=0){ 
0D36:  CLRF   78
0D37:  MOVLW  09
0D38:  MOVWF  77
0D39:  MOVLW  21
0D3A:  MOVWF  05
0D3B:  MOVLW  2D
0D3C:  MOVWF  04
0D3D:  MOVF   78,W
0D3E:  MOVLP  00
0D3F:  MOVLB  00
0D40:  CALL   155
0D41:  MOVLP  08
0D42:  MOVWF  00
0D43:  INCF   78,F
0D44:  ADDFSR 01,FSR0
0D45:  DECFSZ 77,F
0D46:  GOTO   548
0D47:  GOTO   54A
0D48:  MOVLB  03
0D49:  GOTO   53D
0D4A:  MOVLW  21
0D4B:  MOVLB  03
0D4C:  MOVWF  6B
0D4D:  MOVLW  13
0D4E:  MOVWF  6A
0D4F:  MOVLW  21
0D50:  MOVWF  6D
0D51:  MOVLW  2D
0D52:  MOVWF  6C
0D53:  MOVLP  00
0D54:  MOVLB  00
0D55:  CALL   5EE
0D56:  MOVLP  08
0D57:  MOVF   79,W
0D58:  MOVLB  03
0D59:  MOVWF  6B
0D5A:  MOVF   78,W
0D5B:  MOVWF  6A
0D5C:  MOVF   6A,F
0D5D:  BTFSS  03.2
0D5E:  GOTO   562
0D5F:  MOVF   6B,F
0D60:  BTFSC  03.2
0D61:  GOTO   5CF
....................          usb_cdc_putc("\r\n-----------------------\r\n"); 
0D62:  MOVLW  82
0D63:  MOVWF  11
0D64:  MOVLW  04
0D65:  MOVWF  12
0D66:  MOVLP  00
0D67:  MOVLB  00
0D68:  CALL   694
0D69:  MOVLP  08
....................          usb_cdc_putc("BOARD INFORMATION\r\n"); 
0D6A:  MOVLW  90
0D6B:  MOVLB  03
0D6C:  MOVWF  11
0D6D:  MOVLW  04
0D6E:  MOVWF  12
0D6F:  MOVLP  00
0D70:  MOVLB  00
0D71:  CALL   694
0D72:  MOVLP  08
....................          usb_cdc_putc("BOARD: UNO r2\r\n"); 
0D73:  MOVLW  9A
0D74:  MOVLB  03
0D75:  MOVWF  11
0D76:  MOVLW  04
0D77:  MOVWF  12
0D78:  MOVLP  00
0D79:  MOVLB  00
0D7A:  CALL   694
0D7B:  MOVLP  08
....................          usb_cdc_putc("REVISION: 1.00\r\n"); 
0D7C:  MOVLW  A2
0D7D:  MOVLB  03
0D7E:  MOVWF  11
0D7F:  MOVLW  04
0D80:  MOVWF  12
0D81:  MOVLP  00
0D82:  MOVLB  00
0D83:  CALL   694
0D84:  MOVLP  08
....................          usb_cdc_putc("PROCESSOR: PIC 18F26k22\r\n"); 
0D85:  MOVLW  AB
0D86:  MOVLB  03
0D87:  MOVWF  11
0D88:  MOVLW  04
0D89:  MOVWF  12
0D8A:  MOVLP  00
0D8B:  MOVLB  00
0D8C:  CALL   694
0D8D:  MOVLP  08
....................          usb_cdc_putc("CRYSTAL: 16Mhz\r\n"); 
0D8E:  MOVLW  B8
0D8F:  MOVLB  03
0D90:  MOVWF  11
0D91:  MOVLW  04
0D92:  MOVWF  12
0D93:  MOVLP  00
0D94:  MOVLB  00
0D95:  CALL   694
0D96:  MOVLP  08
....................          usb_cdc_putc("CLOCK: 64Mhz\r\n"); 
0D97:  MOVLW  C1
0D98:  MOVLB  03
0D99:  MOVWF  11
0D9A:  MOVLW  04
0D9B:  MOVWF  12
0D9C:  MOVLP  00
0D9D:  MOVLB  00
0D9E:  CALL   694
0D9F:  MOVLP  08
....................          usb_cdc_putc("MIPS: 16\r\n"); 
0DA0:  MOVLW  C9
0DA1:  MOVLB  03
0DA2:  MOVWF  11
0DA3:  MOVLW  04
0DA4:  MOVWF  12
0DA5:  MOVLP  00
0DA6:  MOVLB  00
0DA7:  CALL   694
0DA8:  MOVLP  08
....................          usb_cdc_putc("AD CHANNELS: 13\r\n"); 
0DA9:  MOVLW  CF
0DAA:  MOVLB  03
0DAB:  MOVWF  11
0DAC:  MOVLW  04
0DAD:  MOVWF  12
0DAE:  MOVLP  00
0DAF:  MOVLB  00
0DB0:  CALL   694
0DB1:  MOVLP  08
....................          usb_cdc_putc("PWM: 5\r\n"); 
0DB2:  MOVLW  D8
0DB3:  MOVLB  03
0DB4:  MOVWF  11
0DB5:  MOVLW  04
0DB6:  MOVWF  12
0DB7:  MOVLP  00
0DB8:  MOVLB  00
0DB9:  CALL   694
0DBA:  MOVLP  08
....................          usb_cdc_putc("DAC: 1(5 bits)\r\n");      
0DBB:  MOVLW  DD
0DBC:  MOVLB  03
0DBD:  MOVWF  11
0DBE:  MOVLW  04
0DBF:  MOVWF  12
0DC0:  MOVLP  00
0DC1:  MOVLB  00
0DC2:  CALL   694
0DC3:  MOVLP  08
....................          usb_cdc_putc("-----------------------\r\n"); 
0DC4:  MOVLW  E6
0DC5:  MOVLB  03
0DC6:  MOVWF  11
0DC7:  MOVLW  04
0DC8:  MOVWF  12
0DC9:  MOVLP  00
0DCA:  MOVLB  00
0DCB:  CALL   694
0DCC:  MOVLP  08
....................           
....................       }else if(strstr(buffer,"AT+IDN?\r")!=0){ 
0DCD:  GOTO   633
0DCE:  MOVLB  03
0DCF:  CLRF   78
0DD0:  MOVLW  09
0DD1:  MOVWF  77
0DD2:  MOVLW  21
0DD3:  MOVWF  05
0DD4:  MOVLW  2D
0DD5:  MOVWF  04
0DD6:  MOVF   78,W
0DD7:  MOVLP  00
0DD8:  MOVLB  00
0DD9:  CALL   15F
0DDA:  MOVLP  08
0DDB:  MOVWF  00
0DDC:  INCF   78,F
0DDD:  ADDFSR 01,FSR0
0DDE:  DECFSZ 77,F
0DDF:  GOTO   5E1
0DE0:  GOTO   5E3
0DE1:  MOVLB  03
0DE2:  GOTO   5D6
0DE3:  MOVLW  21
0DE4:  MOVLB  03
0DE5:  MOVWF  6B
0DE6:  MOVLW  13
0DE7:  MOVWF  6A
0DE8:  MOVLW  21
0DE9:  MOVWF  6D
0DEA:  MOVLW  2D
0DEB:  MOVWF  6C
0DEC:  MOVLP  00
0DED:  MOVLB  00
0DEE:  CALL   5EE
0DEF:  MOVLP  08
0DF0:  MOVF   79,W
0DF1:  MOVLB  03
0DF2:  MOVWF  6B
0DF3:  MOVF   78,W
0DF4:  MOVWF  6A
0DF5:  MOVF   6A,F
0DF6:  BTFSS  03.2
0DF7:  GOTO   5FB
0DF8:  MOVF   6B,F
0DF9:  BTFSC  03.2
0DFA:  GOTO   605
....................          usb_cdc_putc("BabuINO UNO");  
0DFB:  MOVLW  F3
0DFC:  MOVWF  11
0DFD:  MOVLW  04
0DFE:  MOVWF  12
0DFF:  MOVLP  00
0E00:  MOVLB  00
0E01:  CALL   694
0E02:  MOVLP  08
....................           
....................       }else if(strstr(buffer,"AT+BAUD")){ 
0E03:  GOTO   633
0E04:  MOVLB  03
0E05:  CLRF   78
0E06:  MOVLW  08
0E07:  MOVWF  77
0E08:  MOVLW  21
0E09:  MOVWF  05
0E0A:  MOVLW  2D
0E0B:  MOVWF  04
0E0C:  MOVF   78,W
0E0D:  MOVLP  00
0E0E:  MOVLB  00
0E0F:  CALL   169
0E10:  MOVLP  08
0E11:  MOVWF  00
0E12:  INCF   78,F
0E13:  ADDFSR 01,FSR0
0E14:  DECFSZ 77,F
0E15:  GOTO   617
0E16:  GOTO   619
0E17:  MOVLB  03
0E18:  GOTO   60C
0E19:  MOVLW  21
0E1A:  MOVLB  03
0E1B:  MOVWF  6B
0E1C:  MOVLW  13
0E1D:  MOVWF  6A
0E1E:  MOVLW  21
0E1F:  MOVWF  6D
0E20:  MOVLW  2D
0E21:  MOVWF  6C
0E22:  MOVLP  00
0E23:  MOVLB  00
0E24:  CALL   5EE
0E25:  MOVLP  08
0E26:  MOVF   78,W
0E27:  IORWF  79,W
0E28:  BTFSC  03.2
0E29:  GOTO   633
....................          usb_cdc_putc("Future feature\r\n"); 
0E2A:  MOVLW  F9
0E2B:  MOVLB  03
0E2C:  MOVWF  11
0E2D:  MOVLW  04
0E2E:  MOVWF  12
0E2F:  MOVLP  00
0E30:  MOVLB  00
0E31:  CALL   694
0E32:  MOVLP  08
0E33:  MOVLB  02
....................       } 
....................       buffer="               "; 
0E34:  MOVLB  03
0E35:  CLRF   68
0E36:  CLRF   69
0E37:  MOVLW  21
0E38:  MOVWF  05
0E39:  MOVLW  13
0E3A:  MOVWF  04
0E3B:  MOVF   68,W
0E3C:  ADDWF  04,F
0E3D:  MOVLW  00
0E3E:  ADDWFC 05,F
0E3F:  MOVF   69,W
0E40:  MOVLP  00
0E41:  MOVLB  00
0E42:  CALL   172
0E43:  MOVLP  08
0E44:  MOVWF  00
0E45:  IORLW  00
0E46:  BTFSC  03.2
0E47:  GOTO   64D
0E48:  MOVLB  03
0E49:  INCF   69,F
0E4A:  INCF   68,F
0E4B:  GOTO   637
0E4C:  MOVLB  00
....................    } 
0E4D:  MOVLP  00
0E4E:  GOTO   73F (RETURN)
.................... } 
....................  
.................... void CheckUart(void){ 
.................... static int32 baud=9600; 
.................... static int parity=0; 
.................... static int dataBits=8; 
.................... static int stopBits=0; 
....................    if(baud!=usb_cdc_line_coding.dwDTERrate){ 
*
1000:  MOVLB  02
1001:  MOVF   49,W
1002:  MOVLB  03
1003:  MOVWF  5C
1004:  MOVLB  02
1005:  MOVF   4A,W
1006:  MOVLB  03
1007:  MOVWF  5D
1008:  MOVLB  02
1009:  MOVF   4B,W
100A:  MOVLB  03
100B:  MOVWF  5E
100C:  MOVLB  02
100D:  MOVF   4C,W
100E:  MOVLB  03
100F:  MOVWF  5F
1010:  MOVF   5C,W
1011:  SUBWF  55,W
1012:  BTFSS  03.2
1013:  GOTO   020
1014:  MOVF   5D,W
1015:  SUBWF  56,W
1016:  BTFSS  03.2
1017:  GOTO   020
1018:  MOVF   5E,W
1019:  SUBWF  57,W
101A:  BTFSS  03.2
101B:  GOTO   020
101C:  MOVF   5F,W
101D:  SUBWF  58,W
101E:  BTFSC  03.2
101F:  GOTO   403
....................       set_uart_speed(usb_cdc_line_coding.dwDTERrate); 
1020:  MOVLB  02
1021:  MOVF   49,W
1022:  MOVLB  03
1023:  MOVWF  5C
1024:  MOVLB  02
1025:  MOVF   4A,W
1026:  MOVLB  03
1027:  MOVWF  5D
1028:  MOVLB  02
1029:  MOVF   4B,W
102A:  MOVLB  03
102B:  MOVWF  5E
102C:  MOVLB  02
102D:  MOVF   4C,W
102E:  MOVLB  03
102F:  MOVWF  5F
1030:  MOVF   5F,W
1031:  MOVWF  63
1032:  MOVF   5E,W
1033:  MOVWF  62
1034:  MOVF   5D,W
1035:  MOVWF  61
1036:  MOVF   5C,W
1037:  MOVWF  60
1038:  MOVLW  02
1039:  MOVWF  67
103A:  MOVLW  DC
103B:  MOVWF  66
103C:  MOVLW  6C
103D:  MOVWF  65
103E:  CLRF   64
....................       baud=usb_cdc_line_coding.dwDTERrate; 
*
13F3:  MOVLB  02
13F4:  MOVF   49,W
13F5:  MOVLB  03
13F6:  MOVWF  55
13F7:  MOVLB  02
13F8:  MOVF   4A,W
13F9:  MOVLB  03
13FA:  MOVWF  56
13FB:  MOVLB  02
13FC:  MOVF   4B,W
13FD:  MOVLB  03
13FE:  MOVWF  57
13FF:  MOVLB  02
1400:  MOVF   4C,W
1401:  MOVLB  03
1402:  MOVWF  58
....................    } 
1403:  MOVLP  00
1404:  MOVLB  00
1405:  GOTO   728 (RETURN)
....................    
.................... } 
....................  
....................  
.................... #ORG 0x1F7F, 0x1FFF {} 
.................... #ID 0x0001 
....................  
.................... /* TODO: Use usb_cdc_putc() to transmit data to the USB 
.................... virtual COM port. Use usb_cdc_kbhit() and usb_cdc_getc() to 
.................... receive data from the USB virtual COM port. usb_enumerated() 
.................... can be used to see if connected to a host and ready to 
.................... communicate. */ 
....................  
.................... #INT_TIMER1 
.................... void  TIMER1_isr(void)  
.................... { 
.................... output_low(LEDRX); 
*
0502:  MOVLW  E1
0503:  MOVLB  01
0504:  MOVWF  0E
0505:  MOVLB  02
0506:  BCF    0E.3
.................... output_low(LEDTX); 
0507:  MOVLB  01
0508:  MOVWF  0E
0509:  MOVLB  02
050A:  BCF    0E.2
050B:  MOVLB  00
050C:  BCF    11.0
050D:  MOVLP  00
050E:  GOTO   031
.................... } 
....................  
.................... void main() 
*
06E0:  CLRF   70
06E1:  MOVLB  03
06E2:  BSF    1F.3
06E3:  MOVLW  E1
06E4:  MOVWF  1B
06E5:  MOVLW  04
06E6:  MOVWF  1C
06E7:  MOVLW  A6
06E8:  MOVWF  1E
06E9:  MOVLW  90
06EA:  MOVWF  1D
06EB:  CLRF   54
06EC:  CLRF   53
06ED:  CLRF   58
06EE:  CLRF   57
06EF:  MOVLW  25
06F0:  MOVWF  56
06F1:  MOVLW  80
06F2:  MOVWF  55
06F3:  CLRF   7D
06F4:  MOVLW  08
06F5:  MOVWF  7E
06F6:  CLRF   59
06F7:  CLRF   0C
06F8:  CLRF   0E
06F9:  MOVLB  02
06FA:  CLRF   12
06FB:  CLRF   11
06FC:  CLRF   14
06FD:  CLRF   13
06FE:  MOVLB  03
06FF:  CLRF   41
0700:  CLRF   42
0701:  MOVLW  20
0702:  MOVWF  43
0703:  MOVWF  44
0704:  MOVWF  45
0705:  MOVWF  46
0706:  MOVWF  47
0707:  MOVWF  48
0708:  MOVWF  49
0709:  MOVWF  4A
070A:  MOVWF  4B
070B:  MOVWF  4C
070C:  MOVWF  4D
070D:  MOVWF  4E
070E:  MOVWF  4F
070F:  MOVWF  50
0710:  MOVWF  51
0711:  CLRF   52
.................... { 
.................... char cUSB; 
....................  
....................    set_tris_a(0xFF); 
0712:  MOVLW  FF
0713:  MOVLB  01
0714:  MOVWF  0C
....................    set_tris_c(0xE3); 
0715:  MOVLW  E3
0716:  MOVWF  0E
....................    output_low(RESET1938); 
0717:  MOVLW  E1
0718:  MOVWF  0E
0719:  MOVLB  02
071A:  BCF    0E.1
....................     
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_4);      //21,8 ms 
071B:  BCF    1D.3
071C:  MOVLW  25
071D:  MOVLB  00
071E:  MOVWF  18
071F:  CLRF   19
....................     
....................    enable_interrupts(INT_TIMER1); 
0720:  MOVLB  01
0721:  BSF    11.0
....................    enable_interrupts(GLOBAL); 
0722:  MOVLW  C0
0723:  IORWF  0B,F
....................     
....................    usb_init(); 
0724:  MOVLB  00
0725:  GOTO   50F
....................     
....................    while(TRUE) 
....................    { 
....................       CheckUart();    
0726:  MOVLP  10
0727:  GOTO   000
0728:  MOVLP  00
....................       if(usb_cdc_kbhit()){ 
0729:  MOVLB  02
072A:  BTFSS  40.0
072B:  GOTO   741
....................          output_high(LEDRX); 
072C:  MOVLW  E1
072D:  MOVLB  01
072E:  MOVWF  0E
072F:  MOVLB  02
0730:  BSF    0E.3
....................          cUSB=usb_cdc_getc(); 
0731:  MOVLB  00
0732:  GOTO   5C6
0733:  MOVF   78,W
0734:  MOVLB  03
0735:  MOVWF  5A
....................          putc(cUSB);      
0736:  MOVF   5A,W
0737:  MOVLB  00
0738:  CALL   5E8
....................          ATcommands(cUSB); 
0739:  MOVLB  03
073A:  MOVF   5A,W
073B:  MOVWF  5B
073C:  MOVLP  08
073D:  MOVLB  00
073E:  GOTO   46A
073F:  MOVLP  00
0740:  MOVLB  02
....................       }   
....................       if(kbhit()){ 
0741:  MOVLB  00
0742:  BTFSS  11.5
0743:  GOTO   751
....................          output_high(LEDTX); 
0744:  MOVLW  E1
0745:  MOVLB  01
0746:  MOVWF  0E
0747:  MOVLB  02
0748:  BSF    0E.2
....................          usb_cdc_putc(getc()); 
0749:  MOVLB  00
074A:  GOTO   6D2
074B:  MOVF   78,W
074C:  MOVLB  03
074D:  MOVWF  5B
074E:  MOVWF  6D
074F:  MOVLB  00
0750:  CALL   643
....................       } 
0751:  GOTO   726
....................       //TODO: User Code 
....................    } 
.................... } 
0752:  SLEEP

Configuration Fuses:
   Word  1: 3982   HS NOWDT PUT NOMCLR NOPROTECT NOBROWNOUT NOCLKOUT IESO FCMEN
   Word  2: 1FCF   NOWRT NOCPUDIV LS48MHZ PLL3X PLLEN STVREN BORV19 NOLPBOR NODEBUG NOLVP

ID Locations:
   00 00 00 00 00 00 01 00 
